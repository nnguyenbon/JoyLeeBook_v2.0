Index: JoyLeeBook_v2.0/src/main/java/dao/ChapterDAO.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * cần chỉnh sửa xem xem có cho xem các chapter chưa approved không\r\n */\r\n\r\npackage dao;\r\n\r\nimport java.sql.*;\r\nimport java.time.LocalDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport model.Chapter;\r\nimport dto.chapter.ChapterItemDTO;\r\n\r\n/**\r\n * Data Access Object (DAO) for Chapter entity.\r\n * Provides CRUD operations and specific queries.\r\n *\r\n * @author KToan, HaiDD-dev\r\n */\r\npublic class ChapterDAO {\r\n    private final Connection conn;\r\n\r\n    /**\r\n     * Constructor to initialize the DAO with a database connection.\r\n     *\r\n     * @param conn the database connection\r\n     */\r\n    public ChapterDAO(Connection conn) {\r\n        this.conn = conn;\r\n    }\r\n\r\n    /**\r\n     * Retrieve all non-deleted chapters.\r\n     *\r\n     * @return a list of all non-deleted chapters\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public List<Chapter> getAll() throws SQLException {\r\n        List<Chapter> chapters = new ArrayList<>();\r\n        String sql = \"SELECT * FROM chapters WHERE is_deleted = 0\";\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {\r\n            while (rs.next()) {\r\n                chapters.add(extractChapterFromResultSet(rs));\r\n            }\r\n        }\r\n        return chapters;\r\n    }\r\n\r\n    /**\r\n     * Find a chapter by its ID.\r\n     *\r\n     * @param chapterId the ID of the chapter\r\n     * @return the Chapter object if found, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findById(int chapterId) throws SQLException {\r\n        String sql = \"SELECT * FROM chapters WHERE chapter_id = ? AND is_deleted = 0\";\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, chapterId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                if (rs.next()) {\r\n                    return extractChapterFromResultSet(rs);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Insert a new chapter into the database.\r\n     *\r\n     * @param chapter  the Chapter object to insert\r\n     * @param seriesId the ID of the series the chapter belongs to\r\n     * @param authorId the ID of the author creating the chapter\r\n     * @return true if insertion was successful, false otherwise\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public boolean insert(Chapter chapter, int seriesId, int authorId) throws SQLException {\r\n        String sql = \"INSERT INTO chapters \" + \"(series_id, author_id, chapter_number, title, content, status, is_deleted, created_at, updated_at) \" + \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\";\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\r\n            Timestamp now = Timestamp.valueOf(java.time.LocalDateTime.now());\r\n\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, authorId);\r\n            ps.setInt(3, chapter.getChapterNumber());\r\n            ps.setString(4, chapter.getTitle());\r\n            ps.setString(5, chapter.getContent());\r\n            ps.setString(6, chapter.getStatus());\r\n            ps.setBoolean(7, false);   // SQL Server BIT <- 0\r\n            ps.setTimestamp(8, now);\r\n            ps.setTimestamp(9, now);\r\n\r\n            int affected = ps.executeUpdate();\r\n            if (affected > 0) {\r\n                try (ResultSet rs = ps.getGeneratedKeys()) {\r\n                    if (rs.next()) chapter.setChapterId(rs.getInt(1));\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update an existing chapter in the database.\r\n     *\r\n     * @param chapter the Chapter object with updated data\r\n     * @return true if update was successful, false otherwise\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public boolean update(Chapter chapter) throws SQLException {\r\n        String sql = \"UPDATE chapters SET \" + \"chapter_number = ?, title = ?, content = ?, status = ?, updated_at = ? \" + \"WHERE chapter_id = ? AND is_deleted = 0\";\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, chapter.getChapterNumber());\r\n            ps.setString(2, chapter.getTitle());\r\n            ps.setString(3, chapter.getContent());\r\n            ps.setString(4, chapter.getStatus());\r\n            ps.setTimestamp(5, Timestamp.valueOf(java.time.LocalDateTime.now()));\r\n            ps.setInt(6, chapter.getChapterId());\r\n            return ps.executeUpdate() > 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Soft delete a chapter by setting its is_deleted flag to true.\r\n     *\r\n     * @param chapterId the ID of the chapter to delete\r\n     * @return true if deletion was successful, false otherwise\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public boolean delete(int chapterId) throws SQLException {\r\n        String sql = \"UPDATE chapters SET is_deleted = 1, updated_at = ? WHERE chapter_id = ?\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setTimestamp(1, java.sql.Timestamp.valueOf(java.time.LocalDateTime.now()));\r\n            ps.setInt(2, chapterId);\r\n            return ps.executeUpdate() > 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve a paginated list of chapters authored by a specific user with optional filters.\r\n     * Author mode\r\n     *\r\n     * @param userId       the ID of the author\r\n     * @param offset       the starting point for pagination\r\n     * @param pageSize     the number of records to retrieve\r\n     * @param statusFilter optional status filter (e.g., \"published\", \"draft\")\r\n     * @param keyword      optional keyword to search in series or chapter titles\r\n     * @return a list of ChapterListItem objects matching the criteria\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public List<ChapterItemDTO> getAuthoredChapters(int userId, int offset, int pageSize, String statusFilter, String keyword) throws SQLException {\r\n\r\n        StringBuilder sql = new StringBuilder(\"SELECT c.chapter_id, c.series_id, s.title AS series_title, c.chapter_number, c.title AS chapter_title, c.status, c.updated_at FROM chapters c \" + \"JOIN series s ON c.series_id = s.series_id \" + \"JOIN series_author sa ON sa.series_id = s.series_id \" + \"WHERE sa.user_id = ? \");\r\n\r\n        List<Object> params = new ArrayList<>();\r\n        params.add(userId);\r\n\r\n        if (statusFilter != null && !statusFilter.isBlank()) {\r\n            sql.append(\"AND c.status = ? \");\r\n            params.add(statusFilter);\r\n        }\r\n        if (keyword != null && !keyword.isBlank()) {\r\n            sql.append(\"AND (s.title LIKE ? OR c.title LIKE ?) \");\r\n            params.add(\"%\" + keyword + \"%\");\r\n            params.add(\"%\" + keyword + \"%\");\r\n        }\r\n\r\n        sql.append(\"ORDER BY c.updated_at DESC OFFSET ? ROWS FETCH NEXT ? ROWS ONLY\");\r\n        params.add(offset);\r\n        params.add(pageSize);\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {\r\n            for (int i = 0; i < params.size(); i++) {\r\n                ps.setObject(i + 1, params.get(i));\r\n            }\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                List<ChapterItemDTO> list = new ArrayList<>();\r\n                while (rs.next()) {\r\n                    ChapterItemDTO it = new ChapterItemDTO();\r\n                    it.setChapterId(rs.getInt(\"chapter_id\"));\r\n                    it.setSeriesId(rs.getInt(\"series_id\"));\r\n                    it.setSeriesTitle(rs.getString(\"series_title\"));\r\n                    it.setChapterNumber(rs.getInt(\"chapter_number\"));\r\n                    it.setChapterTitle(rs.getString(\"chapter_title\"));\r\n                    it.setStatus(rs.getString(\"status\"));\r\n                    Timestamp up = rs.getTimestamp(\"updated_at\");\r\n                    it.setUpdatedAt(up != null ? up.toLocalDateTime() : null);\r\n                    list.add(it);\r\n                }\r\n                return list;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Count the total number of chapters authored by a specific user with optional filters.\r\n     *\r\n     * @param userId       the ID of the author\r\n     * @param statusFilter optional status filter (e.g., \"published\", \"draft\")\r\n     * @param keyword      optional keyword to search in series or chapter titles\r\n     * @return the total count of chapters matching the criteria\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public int countAuthoredChapters(int userId, String statusFilter, String keyword) throws SQLException {\r\n        StringBuilder sql = new StringBuilder(\"SELECT COUNT(*) \" + \"FROM chapters c \" + \"JOIN series s ON c.series_id = s.series_id \" + \"JOIN series_author sa ON sa.series_id = s.series_id \" + \"WHERE sa.user_id = ? \");\r\n\r\n        List<Object> params = new ArrayList<>();\r\n        params.add(userId);\r\n\r\n        if (statusFilter != null && !statusFilter.isBlank()) {\r\n            sql.append(\"AND c.status = ? \");\r\n            params.add(statusFilter);\r\n        }\r\n        if (keyword != null && !keyword.isBlank()) {\r\n            sql.append(\"AND (s.title LIKE ? OR c.title LIKE ?) \");\r\n            params.add(\"%\" + keyword + \"%\");\r\n            params.add(\"%\" + keyword + \"%\");\r\n        }\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {\r\n            for (int i = 0; i < params.size(); i++) {\r\n                ps.setObject(i + 1, params.get(i));\r\n            }\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? rs.getInt(1) : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve a paginated list of chapters from a user's reading history with optional keyword filter.\r\n     * History mode\r\n     *\r\n     * @param userId   the ID of the user\r\n     * @param offset   the starting point for pagination\r\n     * @param pageSize the number of records to retrieve\r\n     * @param keyword  optional keyword to search in series or chapter titles\r\n     * @return a list of ChapterListItem objects from the user's reading history matching the criteria\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public List<ChapterItemDTO> getReadingHistoryChapters(int userId, int offset, int pageSize, String keyword) throws SQLException {\r\n\r\n        StringBuilder sql = new StringBuilder(\"SELECT c.chapter_id, c.series_id, s.title AS series_title, \" + \"       c.chapter_number, c.title AS chapter_title, c.status, c.updated_at, h.last_read_at, cover_image_url \" + \"FROM reading_history h \" + \"JOIN chapters c ON c.chapter_id = h.chapter_id \" + \"JOIN series s ON s.series_id = c.series_id \" + \"WHERE h.user_id = ? \");\r\n\r\n        List<Object> params = new ArrayList<>();\r\n        params.add(userId);\r\n\r\n        if (keyword != null && !keyword.isBlank()) {\r\n            sql.append(\"AND (s.title LIKE ? OR c.title LIKE ?) \");\r\n            params.add(\"%\" + keyword + \"%\");\r\n            params.add(\"%\" + keyword + \"%\");\r\n        }\r\n\r\n        sql.append(\"ORDER BY h.last_read_at DESC OFFSET ? ROWS FETCH NEXT ? ROWS ONLY\");\r\n        params.add(offset);\r\n        params.add(pageSize);\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {\r\n            for (int i = 0; i < params.size(); i++) {\r\n                ps.setObject(i + 1, params.get(i));\r\n            }\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                List<ChapterItemDTO> list = new ArrayList<>();\r\n                while (rs.next()) {\r\n                    ChapterItemDTO it = new ChapterItemDTO();\r\n                    it.setChapterId(rs.getInt(\"chapter_id\"));\r\n                    it.setSeriesId(rs.getInt(\"series_id\"));\r\n                    it.setSeriesTitle(rs.getString(\"series_title\"));\r\n                    it.setChapterNumber(rs.getInt(\"chapter_number\"));\r\n                    it.setChapterTitle(rs.getString(\"chapter_title\"));\r\n                    it.setStatus(rs.getString(\"status\"));\r\n                    it.setCoverImgUrl(rs.getString(\"cover_image_url\"));\r\n                    Timestamp up = rs.getTimestamp(\"updated_at\");\r\n                    it.setUpdatedAt(up != null ? up.toLocalDateTime() : null);\r\n                    Timestamp lr = rs.getTimestamp(\"last_read_at\");\r\n                    it.setLastReadAt(lr != null ? lr.toLocalDateTime() : null);\r\n                    list.add(it);\r\n                }\r\n                return list;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Count the total number of chapters in a user's reading history with optional keyword filter.\r\n     *\r\n     * @param userId  the ID of the user\r\n     * @param keyword optional keyword to search in series or chapter titles\r\n     * @return the total count of chapters in the user's reading history matching the criteria\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public int countReadingHistoryChapters(int userId, String keyword) throws SQLException {\r\n        StringBuilder sql = new StringBuilder(\"SELECT COUNT(*) \" + \"FROM reading_history h \" + \"JOIN chapters c ON c.chapter_id = h.chapter_id \" + \"JOIN series s ON s.series_id = c.series_id \" + \"WHERE h.user_id = ? \");\r\n\r\n        List<Object> params = new ArrayList<>();\r\n        params.add(userId);\r\n\r\n        if (keyword != null && !keyword.isBlank()) {\r\n            sql.append(\"AND (s.title LIKE ? OR c.title LIKE ?) \");\r\n            params.add(\"%\" + keyword + \"%\");\r\n            params.add(\"%\" + keyword + \"%\");\r\n        }\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {\r\n            for (int i = 0; i < params.size(); i++) {\r\n                ps.setObject(i + 1, params.get(i));\r\n            }\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? rs.getInt(1) : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the latest chapter number of a series.\r\n     *\r\n     * @param seriesId ID of the series.\r\n     * @return number of the latest chapter. If no chapters exist, returns 0.\r\n     */\r\n    public int getLatestChapterNumber(int seriesId) throws SQLException {\r\n        String sql = \"SELECT MAX(chapter_number) FROM chapters WHERE series_id = ?\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                if (rs.next()) {\r\n                    return rs.getInt(1);\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Add a new chapter and return the Chapter object with the generated ID.\r\n     *\r\n     * @param chapter the Chapter object to add (without chapterId)\r\n     * @return the Chapter object with the generated chapterId, or null if insertion failed\r\n     */\r\n    public Chapter addChapter(Chapter chapter) throws SQLException {\r\n        String sql = \"INSERT INTO chapters (series_id, chapter_number, title, content, status, created_at, updated_at) \" + \"VALUES (?, ?, ?, ?, ?, GETDATE(), GETDATE())\";\r\n\r\n        try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\r\n            ps.setInt(1, chapter.getSeriesId());\r\n            ps.setInt(2, chapter.getChapterNumber());\r\n            ps.setString(3, chapter.getTitle());\r\n            ps.setString(4, chapter.getContent());\r\n            ps.setString(5, chapter.getStatus());\r\n\r\n            int affectedRows = ps.executeUpdate();\r\n\r\n            if (affectedRows > 0) {\r\n                try (ResultSet generatedKeys = ps.getGeneratedKeys()) {\r\n                    if (generatedKeys.next()) {\r\n                        chapter.setChapterId(generatedKeys.getInt(1));\r\n                        return chapter;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an approved chapter by its ID.\r\n     *\r\n     * @param chapterId the ID of the chapter\r\n     * @return the Chapter object if found and approved, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findApprovedById(int chapterId) throws SQLException {\r\n        String sql = \"\"\"\r\n                    SELECT * FROM chapters\r\n                    WHERE chapter_id = ? AND is_deleted = 0 AND status = 'approved'\r\n                \"\"\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, chapterId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? map(rs) : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find an approved chapter by its series ID and chapter number.\r\n     *\r\n     * @param seriesId      the ID of the series\r\n     * @param chapterNumber the chapter number within the series\r\n     * @return the Chapter object if found and approved, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findApprovedBySeriesAndNumber(int seriesId, int chapterNumber) throws SQLException {\r\n        String sql = \"\"\"\r\n                    SELECT * FROM chapters\r\n                    WHERE series_id = ? AND chapter_number = ? AND is_deleted = 0 AND status = 'approved'\r\n                \"\"\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, chapterNumber);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? map(rs) : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the next approved chapter in a series after the given chapter number.\r\n     *\r\n     * @param seriesId      the ID of the series\r\n     * @param currentNumber the current chapter number\r\n     * @return the next approved Chapter object if found, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findPrevApproved(int seriesId, int currentNumber) throws SQLException {\r\n        String sql = \"\"\"\r\n                    SELECT TOP 1 * FROM chapters\r\n                    WHERE series_id = ? AND is_deleted = 0 AND status = 'approved'\r\n                      AND chapter_number < ?\r\n                    ORDER BY chapter_number DESC\r\n                \"\"\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, currentNumber);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? map(rs) : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the next approved chapter in a series after the current chapter number.\r\n     *\r\n     * @param seriesId      the ID of the series\r\n     * @param currentNumber the current chapter number\r\n     * @return the next approved Chapter object if found, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findNextApproved(int seriesId, int currentNumber) throws SQLException {\r\n        String sql = \"\"\"\r\n                    SELECT TOP 1 * FROM chapters\r\n                    WHERE series_id = ? AND is_deleted = 0 AND status = 'approved'\r\n                      AND chapter_number > ?\r\n                    ORDER BY chapter_number ASC\r\n                \"\"\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, currentNumber);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? map(rs) : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map the current row of the ResultSet to a Chapter object.\r\n     *\r\n     * @param rs the ResultSet positioned at the desired row\r\n     * @return a Chapter object populated with data from the ResultSet\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    private Chapter map(ResultSet rs) throws SQLException {\r\n        Chapter c = new Chapter();\r\n\r\n        c.setChapterId(rs.getInt(\"chapter_id\"));\r\n        c.setSeriesId(rs.getInt(\"series_id\"));\r\n        c.setChapterNumber(rs.getInt(\"chapter_number\"));\r\n        c.setTitle(rs.getString(\"title\"));\r\n        c.setContent(rs.getString(\"content\"));\r\n        c.setStatus(rs.getString(\"status\"));\r\n        c.setDeleted(rs.getBoolean(\"is_deleted\"));\r\n        Timestamp cr = rs.getTimestamp(\"created_at\");\r\n        Timestamp up = rs.getTimestamp(\"updated_at\");\r\n        c.setCreatedAt(cr != null ? cr.toLocalDateTime() : LocalDateTime.now());\r\n        c.setUpdatedAt(up != null ? up.toLocalDateTime() : LocalDateTime.now());\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Find a chapter by its ID if it is not marked as deleted.\r\n     *\r\n     * @param chapterId the ID of the chapter\r\n     * @return the Chapter object if found and not deleted, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findByIdIfNotDeleted(int chapterId) throws SQLException {\r\n        String sql = \"SELECT * FROM chapters WHERE chapter_id = ? AND is_deleted = 0\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, chapterId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? map(rs) : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a chapter by its series ID and chapter number if it is not marked as deleted.\r\n     *\r\n     * @param seriesId      the ID of the series\r\n     * @param chapterNumber the chapter number within the series\r\n     * @return the Chapter object if found and not deleted, otherwise null\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    public Chapter findBySeriesAndNumberIfNotDeleted(int seriesId, int chapterNumber) throws SQLException {\r\n        String sql = \"\"\"\r\n                    SELECT * FROM chapters\r\n                    WHERE series_id = ? AND chapter_number = ? AND is_deleted = 0\r\n                \"\"\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, chapterNumber);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? map(rs) : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public int countChapterBySeriesId(int seriesId) throws SQLException {\r\n        String sql = \"SELECT COUNT(*) FROM chapters WHERE series_id = ? AND is_deleted = 0\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                return rs.next() ? rs.getInt(1) : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public List<Chapter> findChapterBySeriesId(int seriesId) throws SQLException {\r\n        String sql = \"SELECT * FROM chapters WHERE series_id = ? AND is_deleted = 0\";\r\n        List<Chapter> chapterList = new ArrayList<>();\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                while (rs.next()) {\r\n                chapterList.add(extractChapterFromResultSet(rs));\r\n                }\r\n            }\r\n            return chapterList;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the next chapter in a series based on the chapter index.\r\n     *\r\n     * @param seriesId     the ID of the series\r\n     * @param chapterNumber the index of the current chapter\r\n     * @return the next Chapter object if it exists, or null if there is no next\r\n     *         chapter.\r\n     * @throws SQLException If a database access error occurs.\r\n     */\r\n    public Chapter getNextChapter(int seriesId, int chapterNumber) throws SQLException {\r\n        String sql = \"SELECT TOP 1 * FROM Chapters WHERE series_id = ? AND chapter_number > ? ORDER BY chapter_number \";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, chapterNumber);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                if (rs.next()) {\r\n                    return extractChapterFromResultSet(rs);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the previous chapter in a series based on the chapter index.\r\n     *\r\n     * @param seriesId     the ID of the series\r\n     * @param chapterNumber the index of the current chapter\r\n     * @return the previous Chapter object if it exists, or null if there is no\r\n     *         previous chapter.\r\n     * @throws SQLException If a database access error occurs.\r\n     */\r\n    public Chapter getPreviousChapter(int seriesId, int chapterNumber) throws SQLException {\r\n        String sql = \"SELECT TOP 1 * FROM Chapters WHERE series_id = ? AND chapter_number < ? ORDER BY chapter_number DESC\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            ps.setInt(2, chapterNumber);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                if (rs.next()) {\r\n                    return extractChapterFromResultSet(rs);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get the latest chapter number of a series.\r\n     *\r\n     * @param seriesId ID of the series.\r\n     * @return number of the latest chapter. If no chapters exist, returns 0.\r\n     */\r\n    public int getFirstChapterNumber(int seriesId) throws SQLException {\r\n        String sql = \"SELECT MIN(chapter_number) FROM chapters WHERE series_id = ?\";\r\n        try (PreparedStatement ps = conn.prepareStatement(sql)) {\r\n            ps.setInt(1, seriesId);\r\n            try (ResultSet rs = ps.executeQuery()) {\r\n                if (rs.next()) {\r\n                    return rs.getInt(1);\r\n                }\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * Extract a Chapter object from the current row of the ResultSet.\r\n     *\r\n     * @param rs the ResultSet positioned at the desired row\r\n     * @return a Chapter object populated with data from the ResultSet\r\n     * @throws SQLException if a database access error occurs\r\n     */\r\n    private Chapter extractChapterFromResultSet(ResultSet rs) throws SQLException {\r\n        Chapter chapter = new Chapter();\r\n        chapter.setSeriesId(rs.getInt(\"series_id\"));\r\n        chapter.setChapterId(rs.getInt(\"chapter_id\"));\r\n        chapter.setChapterNumber(rs.getInt(\"chapter_number\"));\r\n        chapter.setTitle(rs.getString(\"title\"));\r\n        chapter.setContent(rs.getString(\"content\"));\r\n        chapter.setStatus(rs.getString(\"status\"));\r\n        chapter.setDeleted(rs.getBoolean(\"is_deleted\"));\r\n        chapter.setCreatedAt(rs.getTimestamp(\"created_at\").toLocalDateTime());\r\n        chapter.setUpdatedAt(rs.getTimestamp(\"updated_at\").toLocalDateTime());\r\n        return chapter;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/JoyLeeBook_v2.0/src/main/java/dao/ChapterDAO.java b/JoyLeeBook_v2.0/src/main/java/dao/ChapterDAO.java
--- a/JoyLeeBook_v2.0/src/main/java/dao/ChapterDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ b/JoyLeeBook_v2.0/src/main/java/dao/ChapterDAO.java	(date 1760529891926)
@@ -79,7 +79,7 @@
      * @throws SQLException if a database access error occurs
      */
     public boolean insert(Chapter chapter, int seriesId, int authorId) throws SQLException {
-        String sql = "INSERT INTO chapters " + "(series_id, author_id, chapter_number, title, content, status, is_deleted, created_at, updated_at) " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
+        String sql = "INSERT INTO chapters " + "(series_id, author_id, chapter_number, title, content, status, is_deleted, created_at, updated_at, user_id) " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
 
         try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
             Timestamp now = Timestamp.valueOf(java.time.LocalDateTime.now());
@@ -93,6 +93,7 @@
             ps.setBoolean(7, false);   // SQL Server BIT <- 0
             ps.setTimestamp(8, now);
             ps.setTimestamp(9, now);
+            ps.setTimestamp(10, chapter.getUserId());
 
             int affected = ps.executeUpdate();
             if (affected > 0) {
Index: src/main/java/dao/SavedSeriesDAO.java
===================================================================
diff --git a/src/main/java/dao/SavedSeriesDAO.java b/src/main/java/dao/SavedSeriesDAO.java
deleted file mode 100644
--- a/src/main/java/dao/SavedSeriesDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,87 +0,0 @@
-package dao;
-
-import model.SavedSeries;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class SavedSeriesDAO {
-    private final Connection conn;
-
-    public SavedSeriesDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    private SavedSeries mapResultSetToSavedSeries(ResultSet rs) throws SQLException {
-        SavedSeries ss = new SavedSeries();
-        ss.setUserId(rs.getInt("user_id"));
-        ss.setSeriesId(rs.getInt("series_id"));
-
-        Timestamp ts = rs.getTimestamp("save_at");
-        ss.setSavedAt(ts != null ? ts.toLocalDateTime() : null);
-
-        return ss;
-    }
-
-    public boolean insert(SavedSeries ss) throws SQLException {
-        String sql = "INSERT INTO saved_series (user_id, series_id, save_at) VALUES (?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, ss.getUserId());
-            stmt.setInt(2, ss.getSeriesId());
-            stmt.setTimestamp(3, Timestamp.valueOf(ss.getSavedAt() != null ? ss.getSavedAt() : LocalDateTime.now()));
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public List<SavedSeries> getAll() throws SQLException {
-        List<SavedSeries> list = new ArrayList<>();
-        String sql = "SELECT * FROM saved_series ORDER BY save_at DESC";
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToSavedSeries(rs));
-            }
-        }
-        return list;
-    }
-
-    public List<SavedSeries> getByUserId(int userId) throws SQLException {
-        List<SavedSeries> list = new ArrayList<>();
-        String sql = "SELECT * FROM saved_series WHERE user_id = ? ORDER BY save_at DESC";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToSavedSeries(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    public boolean isSaved(int userId, int seriesId) throws SQLException {
-        String sql = "SELECT 1 FROM saved_series WHERE user_id = ? AND series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            stmt.setInt(2, seriesId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                return rs.next();
-            }
-        }
-    }
-
-    public boolean delete(int userId, int seriesId) throws SQLException {
-        String sql = "DELETE FROM saved_series WHERE user_id = ? AND series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            stmt.setInt(2, seriesId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-}
Index: src/main/java/dao/ReviewSeriesDAO.java
===================================================================
diff --git a/src/main/java/dao/ReviewSeriesDAO.java b/src/main/java/dao/ReviewSeriesDAO.java
deleted file mode 100644
--- a/src/main/java/dao/ReviewSeriesDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,112 +0,0 @@
-package dao;
-
-import model.ReviewSeries;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class ReviewSeriesDAO {
-    private final Connection conn;
-
-    public ReviewSeriesDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    public List<ReviewSeries> getAll() throws SQLException {
-        List<ReviewSeries> list = new ArrayList<>();
-        String sql = "SELECT * FROM review_series ORDER BY created_at DESC";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToReview(rs));
-            }
-        }
-        return list;
-    }
-
-    public ReviewSeries findById(int chapterId, int staffId) throws SQLException {
-        String sql = "SELECT * FROM review_series WHERE chapter_id = ? AND staff_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, chapterId);
-            stmt.setInt(2, staffId);
-
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToReview(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    public List<ReviewSeries> findByChapter(int chapterId) throws SQLException {
-        List<ReviewSeries> list = new ArrayList<>();
-        String sql = "SELECT * FROM review_series WHERE chapter_id = ? ORDER BY created_at DESC";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, chapterId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToReview(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    public boolean insert(ReviewSeries review) throws SQLException {
-        String sql = "INSERT INTO review_series (chapter_id, staff_id, status, comment, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, review.getChapterId());
-            stmt.setInt(2, review.getStaffId());
-            stmt.setString(3, review.getStatus());
-            stmt.setString(4, review.getComment());
-            stmt.setTimestamp(5, Timestamp.valueOf(review.getCreatedAt() != null ? review.getCreatedAt() : LocalDateTime.now()));
-            stmt.setTimestamp(6, Timestamp.valueOf(review.getUpdatedAt() != null ? review.getUpdatedAt() : LocalDateTime.now()));
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public boolean update(ReviewSeries review) throws SQLException {
-        String sql = "UPDATE review_series SET status = ?, comment = ?, updated_at = ? WHERE chapter_id = ? AND staff_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, review.getStatus());
-            stmt.setString(2, review.getComment());
-            stmt.setTimestamp(3, Timestamp.valueOf(LocalDateTime.now()));
-            stmt.setInt(4, review.getChapterId());
-            stmt.setInt(5, review.getStaffId());
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public boolean delete(int chapterId, int staffId) throws SQLException {
-        String sql = "DELETE FROM review_series WHERE chapter_id = ? AND staff_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, chapterId);
-            stmt.setInt(2, staffId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    private ReviewSeries mapResultSetToReview(ResultSet rs) throws SQLException {
-        ReviewSeries review = new ReviewSeries();
-        review.setChapterId(rs.getInt("chapter_id"));
-        review.setStaffId(rs.getInt("staff_id"));
-        review.setStatus(rs.getString("status"));
-        review.setComment(rs.getString("comment"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        Timestamp updated = rs.getTimestamp("updated_at");
-        review.setCreatedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-        review.setUpdatedAt(updated != null ? updated.toLocalDateTime() : LocalDateTime.now());
-
-        return review;
-    }
-}
Index: .gitignore
===================================================================
diff --git a/.gitignore b/.gitignore
deleted file mode 100644
--- a/.gitignore	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,3 +0,0 @@
-.idea/
-target/
-node_modules/
\ No newline at end of file
Index: src/main/java/dao/CommentDAO.java
===================================================================
diff --git a/src/main/java/dao/CommentDAO.java b/src/main/java/dao/CommentDAO.java
deleted file mode 100644
--- a/src/main/java/dao/CommentDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,193 +0,0 @@
-package dao;
-
-import model.Comment;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Data Access Object for Comments
- *
- * @author KToan, HaiDD-dev
- */
-public class CommentDAO {
-    private final Connection conn;
-
-    public CommentDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Retrieves all Comment records from the database that are not marked as deleted.
-     *
-     * @return A list of all non-deleted Comment records.
-     * @throws SQLException If an SQL error occurs during the retrieval.
-     */
-    public List<Comment> getAll() throws SQLException {
-        List<Comment> list = new ArrayList<>();
-        String sql = "SELECT * FROM comments WHERE is_delete = 0 ORDER BY created_at DESC";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToComment(rs));
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Find comment by its ID
-     *
-     * @param id The ID of the comment to find
-     * @return The Comment object if found, otherwise null
-     * @throws SQLException If an SQL error occurs during the retrieval
-     */
-    public Comment findById(int id) throws SQLException {
-        String sql = "SELECT * FROM comments WHERE comment_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToComment(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Find comments by chapter ID
-     *
-     * @param chapterId The ID of the chapter to find comments for
-     * @return A list of Comment objects associated with the specified chapter
-     * @throws SQLException If an SQL error occurs during the retrieval
-     */
-    public List<Comment> findByChapter(int chapterId) throws SQLException {
-        List<Comment> list = new ArrayList<>();
-        String sql = "SELECT * FROM comments WHERE chapter_id = ? AND is_deleted = 0 ORDER BY created_at ASC";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, chapterId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToComment(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Insert a new comment into the database
-     *
-     * @param cmt The Comment object to insert
-     * @return true if the insertion was successful, false otherwise
-     * @throws SQLException If an SQL error occurs during the insertion
-     */
-    public boolean insert(Comment cmt) throws SQLException {
-        String sql = "INSERT INTO comments (user_id, chapter_id, content, is_delete, created_at, updated_at) " + "VALUES (?, ?, ?, 0, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, cmt.getUserId());
-            stmt.setInt(2, cmt.getChapterId());
-            stmt.setString(3, cmt.getContent());
-            stmt.setTimestamp(4, Timestamp.valueOf(cmt.getCreatedAt() != null ? cmt.getCreatedAt() : LocalDateTime.now()));
-            stmt.setTimestamp(5, Timestamp.valueOf(cmt.getUpdatedAt() != null ? cmt.getUpdatedAt() : LocalDateTime.now()));
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Update an existing comment in the database
-     *
-     * @param cmt The Comment object with updated information
-     * @return true if the update was successful, false otherwise
-     * @throws SQLException If an SQL error occurs during the update
-     */
-    public boolean update(Comment cmt) throws SQLException {
-        String sql = "UPDATE comments SET content = ?, updated_at = ? WHERE comment_id = ? AND is_delete = 0";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, cmt.getContent());
-            stmt.setTimestamp(2, Timestamp.valueOf(LocalDateTime.now()));
-            stmt.setInt(3, cmt.getCommentId());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Soft delete a comment by setting its is_delete flag to true
-     *
-     * @param commentId The ID of the comment to soft delete
-     * @return true if the soft delete was successful, false otherwise
-     * @throws SQLException If an SQL error occurs during the soft delete
-     */
-    public boolean softDelete(int commentId) throws SQLException {
-        String sql = "UPDATE comments SET is_delete = 1, updated_at = ? WHERE comment_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));
-            stmt.setInt(2, commentId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Hard delete a comment from the database
-     *
-     * @param commentId The ID of the comment to hard delete
-     * @return true if the hard delete was successful, false otherwise
-     * @throws SQLException If an SQL error occurs during the hard delete
-     */
-    public boolean hardDelete(int commentId) throws SQLException {
-        String sql = "DELETE FROM comments WHERE comment_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, commentId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Count the number of comments for a specific chapter that are not marked as deleted
-     *
-     * @param chapterId The ID of the chapter to count comments for
-     * @return The number of non-deleted comments for the specified chapter
-     * @throws SQLException If an SQL error occurs during the count
-     */
-    public int countByChapter(int chapterId) throws SQLException {
-        String sql = "SELECT COUNT(*) FROM comments WHERE chapter_id = ? AND is_deleted = 0";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, chapterId);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? rs.getInt(1) : 0;
-            }
-        }
-    }
-
-    /**
-     * Maps a ResultSet row to a Comment object
-     *
-     * @param rs The ResultSet to map
-     * @return The mapped Comment object
-     * @throws SQLException If an SQL error occurs during the mapping
-     */
-    private Comment mapResultSetToComment(ResultSet rs) throws SQLException {
-        Comment cmt = new Comment();
-        cmt.setCommentId(rs.getInt("comment_id"));
-        cmt.setUserId(rs.getInt("user_id"));
-        cmt.setChapterId(rs.getInt("chapter_id"));
-        cmt.setContent(rs.getString("content"));
-        cmt.setDeleted(rs.getBoolean("is_deleted"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        Timestamp updated = rs.getTimestamp("updated_at");
-
-        cmt.setCreatedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-        cmt.setUpdatedAt(updated != null ? updated.toLocalDateTime() : LocalDateTime.now());
-        return cmt;
-    }
-}
Index: src/main/java/model/Report.java
===================================================================
diff --git a/src/main/java/model/Report.java b/src/main/java/model/Report.java
deleted file mode 100644
--- a/src/main/java/model/Report.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,102 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Report {
-    private int reportId;
-    private int reporterId;
-    private int staffId;
-    private int targetId;
-    private String targetType;
-    private String reason;
-    private String status;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-
-    public Report(int reportId, int reporterId, int staffId, int targetId, String targetType, String reason, String status, LocalDateTime createdAt, LocalDateTime updatedAt) {
-        this.reportId = reportId;
-        this.reporterId = reporterId;
-        this.staffId = staffId;
-        this.targetId = targetId;
-        this.targetType = targetType;
-        this.reason = reason;
-        this.status = status;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-    }
-
-    public Report() {}
-
-    public int getReportId() {
-        return reportId;
-    }
-
-    public void setReportId(int reportId) {
-        this.reportId = reportId;
-    }
-
-    public int getReporterId() {
-        return reporterId;
-    }
-
-    public void setReporterId(int reporterId) {
-        this.reporterId = reporterId;
-    }
-
-    public int getStaffId() {
-        return staffId;
-    }
-
-    public void setStaffId(int staffId) {
-        this.staffId = staffId;
-    }
-
-
-    public int getTargetId() {
-        return targetId;
-    }
-
-    public void setTargetId(int targetId) {
-        this.targetId = targetId;
-    }
-
-    public String getTargetType() {
-        return targetType;
-    }
-
-    public void setTargetType(String targetType) {
-        this.targetType = targetType;
-    }
-
-    public String getReason() {
-        return reason;
-    }
-
-    public void setReason(String reason) {
-        this.reason = reason;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public void setStatus(String status) {
-        this.status = status;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-}
Index: src/main/java/model/SeriesCategories.java
===================================================================
diff --git a/src/main/java/model/SeriesCategories.java b/src/main/java/model/SeriesCategories.java
deleted file mode 100644
--- a/src/main/java/model/SeriesCategories.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,28 +0,0 @@
-package model;
-
-public class SeriesCategories {
-    private int seriesId;
-    private int categoryId;
-
-    public SeriesCategories(int seriesId, int categoryId) {
-        this.seriesId = seriesId;
-        this.categoryId = categoryId;
-    }
-
-    public SeriesCategories() {}
-    public int getSeriesId() {
-        return seriesId;
-    }
-
-    public void setSeriesId(int seriesId) {
-        this.seriesId = seriesId;
-    }
-
-    public int getCategoryId() {
-        return categoryId;
-    }
-
-    public void setCategoryId(int categoryId) {
-        this.categoryId = categoryId;
-    }
-}
Index: src/main/webapp/WEB-INF/web.xml
===================================================================
diff --git a/src/main/webapp/WEB-INF/web.xml b/src/main/webapp/WEB-INF/web.xml
deleted file mode 100644
--- a/src/main/webapp/WEB-INF/web.xml	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd"
-         version="6.0">
-    <session-config>
-        <session-timeout>
-            30
-        </session-timeout>
-    </session-config>
-    <welcome-file-list>
-        <welcome-file>homepage</welcome-file>
-    </welcome-file-list>
-    <error-page>
-        <error-code>404</error-code>
-        <location>/WEB-INF/views/error/error.jsp</location>
-    </error-page>
-    <error-page>
-        <error-code>500</error-code>
-        <location>/WEB-INF/views/error/error.jsp</location>
-    </error-page>
-    <error-page>
-        <exception-type>java.lang.Throwable</exception-type>
-        <location>/WEB-INF/views/error/error.jsp</location>
-    </error-page>
-
-</web-app>
\ No newline at end of file
Index: src/main/java/dao/BadgesUserDAO.java
===================================================================
diff --git a/src/main/java/dao/BadgesUserDAO.java b/src/main/java/dao/BadgesUserDAO.java
deleted file mode 100644
--- a/src/main/java/dao/BadgesUserDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,116 +0,0 @@
-package dao;
-
-import model.Badge;
-import model.BadgesUser;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class BadgesUserDAO {
-    private final Connection conn;
-
-    public BadgesUserDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    // Lấy toàn bộ bản ghi
-    public List<BadgesUser> getAll() throws SQLException {
-        List<BadgesUser> list = new ArrayList<>();
-        String sql = "SELECT * FROM badges_users";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-
-            while (rs.next()) {
-                list.add(mapResultSetToBadgesUsers(rs));
-            }
-        }
-        return list;
-    }
-
-    // Tìm theo khóa chính
-    public BadgesUser findById(int badgeId, int userId) throws SQLException {
-        String sql = "SELECT * FROM badges_users WHERE badge_id = ? AND user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, badgeId);
-            stmt.setInt(2, userId);
-
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToBadgesUsers(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    // Thêm mới
-    public boolean insert(BadgesUser bu) throws SQLException {
-        String sql = "INSERT INTO badges_users (badge_id, user_id, awarded_at) VALUES (?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, bu.getBadgeId());
-            stmt.setInt(2, bu.getUserId());
-            stmt.setTimestamp(3, Timestamp.valueOf(
-                    bu.getAwardedAt() != null ? bu.getAwardedAt() : LocalDateTime.now()
-            ));
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Cập nhật (ví dụ cập nhật thời điểm trao huy hiệu)
-    public boolean update(BadgesUser bu) throws SQLException {
-        String sql = "UPDATE badges_users SET awarded_at = ? WHERE badge_id = ? AND user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setTimestamp(1, Timestamp.valueOf(bu.getAwardedAt()));
-            stmt.setInt(2, bu.getBadgeId());
-            stmt.setInt(3, bu.getUserId());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Xóa một dòng (gỡ huy hiệu khỏi user)
-    public boolean delete(int badgeId, int userId) throws SQLException {
-        String sql = "DELETE FROM badges_users WHERE badge_id = ? AND user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, badgeId);
-            stmt.setInt(2, userId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public List<Badge> getBadgesByUserId(int userId) throws SQLException {
-        List<Badge> badgeList = new ArrayList<>();
-        String sql = "SELECT * FROM badges_users bu JOIN badges b ON bu.badge_id = b.badge_id WHERE user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    Badge badge = new Badge();
-                    badge.setBadgeId(rs.getInt("badge_id"));
-                    badge.setDescription(rs.getString("description"));
-                    badge.setName(rs.getString("name"));
-                    badge.setIconUrl(rs.getString("icon_url"));
-                    badgeList.add(badge);
-                }
-                return  badgeList;
-            }
-        }
-    }
-
-    // Hàm ánh xạ từ ResultSet sang đối tượng
-    private BadgesUser mapResultSetToBadgesUsers(ResultSet rs) throws SQLException {
-        BadgesUser bu = new BadgesUser();
-        bu.setBadgeId(rs.getInt("badge_id"));
-        bu.setUserId(rs.getInt("user_id"));
-
-        Timestamp awarded = rs.getTimestamp("awarded_at");
-        bu.setAwardedAt(awarded != null ? awarded.toLocalDateTime() : LocalDateTime.now());
-
-        return bu;
-    }
-}
Index: src/main/java/model/ReviewSeries.java
===================================================================
diff --git a/src/main/java/model/ReviewSeries.java b/src/main/java/model/ReviewSeries.java
deleted file mode 100644
--- a/src/main/java/model/ReviewSeries.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,72 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class ReviewSeries {
-    private int staffId;
-    private int chapterId;
-    private String status;
-    private String comment;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-
-    public ReviewSeries(int staffId, int chapterId, String status, String comment, LocalDateTime createdAt, LocalDateTime updatedAt) {
-        this.staffId = staffId;
-        this.chapterId = chapterId;
-        this.status = status;
-        this.comment = comment;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-    }
-
-    public ReviewSeries() {
-    }
-
-    public int getStaffId() {
-        return staffId;
-    }
-
-    public void setStaffId(int staffId) {
-        this.staffId = staffId;
-    }
-
-    public int getChapterId() {
-        return chapterId;
-    }
-
-    public void setChapterId(int chapterId) {
-        this.chapterId = chapterId;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public void setStatus(String status) {
-        this.status = status;
-    }
-
-    public String getComment() {
-        return comment;
-    }
-
-    public void setComment(String comment) {
-        this.comment = comment;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-}
Index: src/main/java/dao/ReportDAO.java
===================================================================
diff --git a/src/main/java/dao/ReportDAO.java b/src/main/java/dao/ReportDAO.java
deleted file mode 100644
--- a/src/main/java/dao/ReportDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,98 +0,0 @@
-package dao;
-
-import model.Report;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.List;
-
-public class ReportDAO {
-    private final Connection conn;
-
-    public ReportDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    private Report extractReportFromResultSet(ResultSet rs) throws SQLException {
-        Report r = new Report();
-        r.setReportId(rs.getInt("report_id"));
-        r.setReporterId(rs.getInt("reporter_id"));
-        int staffId = rs.getInt("staff_id");
-        r.setStaffId(rs.wasNull() ? null : staffId);
-        r.setTargetType(rs.getString("target_type"));
-        r.setTargetId(rs.getInt("target_id"));
-        r.setReason(rs.getString("reason"));
-        r.setStatus(rs.getString("status"));
-        Timestamp created = rs.getTimestamp("created_at");
-        Timestamp updated = rs.getTimestamp("updated_at");
-        r.setCreatedAt(created != null ? created.toLocalDateTime() : null);
-        r.setUpdatedAt(updated != null ? updated.toLocalDateTime() : null);
-        return r;
-    }
-
-    public boolean insert(Report report) throws SQLException {
-        String sql = "INSERT INTO reports (reporter_id, staff_id, target_type, , reason,target_id status, created_at, updated_at) " +
-                "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, report.getReporterId());
-            if (report.getStaffId() != 0)
-                ps.setInt(2, report.getStaffId());
-            ps.setString(3, report.getTargetType());
-            ps.setInt(4, report.getTargetId());
-            ps.setString(5, report.getReason());
-            ps.setString(6, report.getStatus());
-            ps.setTimestamp(7, Timestamp.valueOf(report.getCreatedAt()));
-            ps.setTimestamp(8, report.getUpdatedAt() != null ? Timestamp.valueOf(report.getUpdatedAt()) : null);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    public List<Report> getAll() throws SQLException {
-        List<Report> list = new ArrayList<>();
-        String sql = "SELECT * FROM reports";
-        try (PreparedStatement st = conn.prepareStatement(sql);
-             ResultSet rs = st.executeQuery()) {
-            while (rs.next()) {
-                list.add(extractReportFromResultSet(rs));
-            }
-        }
-        return list;
-    }
-
-    public Report getById(int reportId) throws SQLException {
-        String sql = "SELECT * FROM reports WHERE report_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, reportId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) return extractReportFromResultSet(rs);
-            }
-        }
-        return null;
-    }
-
-    public boolean update(Report report) throws SQLException {
-        String sql = "UPDATE reports SET staff_id, target_id=?, target_type=?, reason=?, status=?, updated_at=? WHERE report_id=?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            if (report.getStaffId() != 0)
-                ps.setInt(1, report.getStaffId());
-            ps.setInt(2, report.getTargetId());
-            ps.setString(3, report.getTargetType());
-            ps.setString(4, report.getReason());
-            ps.setString(5, report.getStatus());
-            ps.setTimestamp(6, Timestamp.valueOf(report.getUpdatedAt()));
-            ps.setInt(7, report.getReportId());
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    public boolean delete(int reportId) throws SQLException {
-        String sql = "DELETE FROM reports WHERE report_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, reportId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-}
Index: src/main/java/dao/StaffDAO.java
===================================================================
diff --git a/src/main/java/dao/StaffDAO.java b/src/main/java/dao/StaffDAO.java
deleted file mode 100644
--- a/src/main/java/dao/StaffDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,120 +0,0 @@
-package dao;
-
-import model.Staff;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-
-public class StaffDAO {
-    private final Connection conn;
-
-    public StaffDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-
-    public List<Staff> getAll() throws SQLException {
-        List<Staff> list = new ArrayList<>();
-        String sql = "SELECT * FROM staffs WHERE is_deleted = 0";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-
-            while (rs.next()) {
-                list.add(mapResultSetToStaff(rs));
-            }
-        }
-        return list;
-    }
-
-
-    public Staff findById(int id) throws SQLException {
-        String sql = "SELECT * FROM staffs WHERE staff_id = ? AND is_deleted = 0";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToStaff(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-
-    public boolean insert(Staff staff) throws SQLException {
-        String sql = "INSERT INTO staffs (username, password_hash, full_name, role, is_deleted, created_at)VALUES (?, ?, ?, ?, ?, ?)";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, staff.getUsername());
-            stmt.setString(2, staff.getPasswordHash());
-            stmt.setString(3, staff.getFullName());
-            stmt.setString(4, staff.getRole());
-            stmt.setBoolean(5, false);
-            stmt.setTimestamp(6, Timestamp.valueOf(staff.getCreatedAt()));
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-
-    public boolean update(Staff staff) throws SQLException {
-        String sql = "UPDATE staffs SET username = ?, password_hash = ?, full_name = ?, role = ?, is_deleted = ? WHERE staff_id = ? AND is_deleted = 0";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, staff.getUsername());
-            stmt.setString(2, staff.getPasswordHash());
-            stmt.setString(3, staff.getFullName());
-            stmt.setString(4, staff.getRole());
-            stmt.setBoolean(5, staff.isDeleted());
-            stmt.setInt(6, staff.getStaffId());
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-
-    public boolean delete(int id) throws SQLException {
-        String sql = "UPDATE staffs SET is_deleted = TRUE WHERE staff_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public List<Staff> findByUsername(String username) throws SQLException {
-        List<Staff> staffList = new ArrayList<>();
-        String sql = "SELECT * FROM staffs WHERE username = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, "%" + username + "%");
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    staffList.add(mapResultSetToStaff(rs));
-                }
-            }
-            return staffList;
-        }
-    }
-
-    private Staff mapResultSetToStaff(ResultSet rs) throws SQLException {
-        Staff staff = new Staff();
-        staff.setStaffId(rs.getInt("staff_id"));
-        staff.setUsername(rs.getString("username"));
-        staff.setPasswordHash(rs.getString("password_hash"));
-        staff.setFullName(rs.getString("full_name"));
-        staff.setRole(rs.getString("role"));
-        staff.setDeleted(rs.getBoolean("is_deleted"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        staff.setCreatedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-
-        return staff;
-    }
-}
Index: src/main/java/dao/ChapterDAO.java
===================================================================
diff --git a/src/main/java/dao/ChapterDAO.java b/src/main/java/dao/ChapterDAO.java
deleted file mode 100644
--- a/src/main/java/dao/ChapterDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,634 +0,0 @@
-/**
- * cần chỉnh sửa xem xem có cho xem các chapter chưa approved không
- */
-
-package dao;
-
-import java.sql.*;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-import model.Chapter;
-import dto.chapter.ChapterItemDTO;
-
-/**
- * Data Access Object (DAO) for Chapter entity.
- * Provides CRUD operations and specific queries.
- *
- * @author KToan, HaiDD-dev
- */
-public class ChapterDAO {
-    private final Connection conn;
-
-    /**
-     * Constructor to initialize the DAO with a database connection.
-     *
-     * @param conn the database connection
-     */
-    public ChapterDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Retrieve all non-deleted chapters.
-     *
-     * @return a list of all non-deleted chapters
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Chapter> getAll() throws SQLException {
-        List<Chapter> chapters = new ArrayList<>();
-        String sql = "SELECT * FROM chapters WHERE is_deleted = 0";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {
-            while (rs.next()) {
-                chapters.add(extractChapterFromResultSet(rs));
-            }
-        }
-        return chapters;
-    }
-
-    /**
-     * Find a chapter by its ID.
-     *
-     * @param chapterId the ID of the chapter
-     * @return the Chapter object if found, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findById(int chapterId) throws SQLException {
-        String sql = "SELECT * FROM chapters WHERE chapter_id = ? AND is_deleted = 0";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, chapterId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return extractChapterFromResultSet(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Insert a new chapter into the database.
-     *
-     * @param chapter  the Chapter object to insert
-     * @param seriesId the ID of the series the chapter belongs to
-     * @param authorId the ID of the author creating the chapter
-     * @return true if insertion was successful, false otherwise
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean insert(Chapter chapter, int seriesId, int authorId) throws SQLException {
-        String sql = "INSERT INTO chapters " + "(series_id, author_id, chapter_number, title, content, status, is_deleted, created_at, updated_at) " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
-            Timestamp now = Timestamp.valueOf(java.time.LocalDateTime.now());
-
-            ps.setInt(1, seriesId);
-            ps.setInt(2, authorId);
-            ps.setInt(3, chapter.getChapterNumber());
-            ps.setString(4, chapter.getTitle());
-            ps.setString(5, chapter.getContent());
-            ps.setString(6, chapter.getStatus());
-            ps.setBoolean(7, false);   // SQL Server BIT <- 0
-            ps.setTimestamp(8, now);
-            ps.setTimestamp(9, now);
-
-            int affected = ps.executeUpdate();
-            if (affected > 0) {
-                try (ResultSet rs = ps.getGeneratedKeys()) {
-                    if (rs.next()) chapter.setChapterId(rs.getInt(1));
-                }
-                return true;
-            }
-            return false;
-        }
-    }
-
-    /**
-     * Update an existing chapter in the database.
-     *
-     * @param chapter the Chapter object with updated data
-     * @return true if update was successful, false otherwise
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean update(Chapter chapter) throws SQLException {
-        String sql = "UPDATE chapters SET " + "chapter_number = ?, title = ?, content = ?, status = ?, updated_at = ? " + "WHERE chapter_id = ? AND is_deleted = 0";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, chapter.getChapterNumber());
-            ps.setString(2, chapter.getTitle());
-            ps.setString(3, chapter.getContent());
-            ps.setString(4, chapter.getStatus());
-            ps.setTimestamp(5, Timestamp.valueOf(java.time.LocalDateTime.now()));
-            ps.setInt(6, chapter.getChapterId());
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Soft delete a chapter by setting its is_deleted flag to true.
-     *
-     * @param chapterId the ID of the chapter to delete
-     * @return true if deletion was successful, false otherwise
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean delete(int chapterId) throws SQLException {
-        String sql = "UPDATE chapters SET is_deleted = 1, updated_at = ? WHERE chapter_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setTimestamp(1, java.sql.Timestamp.valueOf(java.time.LocalDateTime.now()));
-            ps.setInt(2, chapterId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Retrieve a paginated list of chapters authored by a specific user with optional filters.
-     * Author mode
-     *
-     * @param userId       the ID of the author
-     * @param offset       the starting point for pagination
-     * @param pageSize     the number of records to retrieve
-     * @param statusFilter optional status filter (e.g., "published", "draft")
-     * @param keyword      optional keyword to search in series or chapter titles
-     * @return a list of ChapterListItem objects matching the criteria
-     * @throws SQLException if a database access error occurs
-     */
-    public List<ChapterItemDTO> getAuthoredChapters(int userId, int offset, int pageSize, String statusFilter, String keyword) throws SQLException {
-
-        StringBuilder sql = new StringBuilder("SELECT c.chapter_id, c.series_id, s.title AS series_title, c.chapter_number, c.title AS chapter_title, c.status, c.updated_at FROM chapters c " + "JOIN series s ON c.series_id = s.series_id " + "JOIN series_author sa ON sa.series_id = s.series_id " + "WHERE sa.user_id = ? ");
-
-        List<Object> params = new ArrayList<>();
-        params.add(userId);
-
-        if (statusFilter != null && !statusFilter.isBlank()) {
-            sql.append("AND c.status = ? ");
-            params.add(statusFilter);
-        }
-        if (keyword != null && !keyword.isBlank()) {
-            sql.append("AND (s.title LIKE ? OR c.title LIKE ?) ");
-            params.add("%" + keyword + "%");
-            params.add("%" + keyword + "%");
-        }
-
-        sql.append("ORDER BY c.updated_at DESC OFFSET ? ROWS FETCH NEXT ? ROWS ONLY");
-        params.add(offset);
-        params.add(pageSize);
-
-        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {
-            for (int i = 0; i < params.size(); i++) {
-                ps.setObject(i + 1, params.get(i));
-            }
-            try (ResultSet rs = ps.executeQuery()) {
-                List<ChapterItemDTO> list = new ArrayList<>();
-                while (rs.next()) {
-                    ChapterItemDTO it = new ChapterItemDTO();
-                    it.setChapterId(rs.getInt("chapter_id"));
-                    it.setSeriesId(rs.getInt("series_id"));
-                    it.setSeriesTitle(rs.getString("series_title"));
-                    it.setChapterNumber(rs.getInt("chapter_number"));
-                    it.setChapterTitle(rs.getString("chapter_title"));
-                    it.setStatus(rs.getString("status"));
-                    Timestamp up = rs.getTimestamp("updated_at");
-                    it.setUpdatedAt(up != null ? up.toLocalDateTime() : null);
-                    list.add(it);
-                }
-                return list;
-            }
-        }
-    }
-
-    /**
-     * Count the total number of chapters authored by a specific user with optional filters.
-     *
-     * @param userId       the ID of the author
-     * @param statusFilter optional status filter (e.g., "published", "draft")
-     * @param keyword      optional keyword to search in series or chapter titles
-     * @return the total count of chapters matching the criteria
-     * @throws SQLException if a database access error occurs
-     */
-    public int countAuthoredChapters(int userId, String statusFilter, String keyword) throws SQLException {
-        StringBuilder sql = new StringBuilder("SELECT COUNT(*) " + "FROM chapters c " + "JOIN series s ON c.series_id = s.series_id " + "JOIN series_author sa ON sa.series_id = s.series_id " + "WHERE sa.user_id = ? ");
-
-        List<Object> params = new ArrayList<>();
-        params.add(userId);
-
-        if (statusFilter != null && !statusFilter.isBlank()) {
-            sql.append("AND c.status = ? ");
-            params.add(statusFilter);
-        }
-        if (keyword != null && !keyword.isBlank()) {
-            sql.append("AND (s.title LIKE ? OR c.title LIKE ?) ");
-            params.add("%" + keyword + "%");
-            params.add("%" + keyword + "%");
-        }
-
-        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {
-            for (int i = 0; i < params.size(); i++) {
-                ps.setObject(i + 1, params.get(i));
-            }
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? rs.getInt(1) : 0;
-            }
-        }
-    }
-
-    /**
-     * Retrieve a paginated list of chapters from a user's reading history with optional keyword filter.
-     * History mode
-     *
-     * @param userId   the ID of the user
-     * @param offset   the starting point for pagination
-     * @param pageSize the number of records to retrieve
-     * @param keyword  optional keyword to search in series or chapter titles
-     * @return a list of ChapterListItem objects from the user's reading history matching the criteria
-     * @throws SQLException if a database access error occurs
-     */
-    public List<ChapterItemDTO> getReadingHistoryChapters(int userId, int offset, int pageSize, String keyword) throws SQLException {
-
-        StringBuilder sql = new StringBuilder("SELECT c.chapter_id, c.series_id, s.title AS series_title, " + "       c.chapter_number, c.title AS chapter_title, c.status, c.updated_at, h.last_read_at, cover_image_url " + "FROM reading_history h " + "JOIN chapters c ON c.chapter_id = h.chapter_id " + "JOIN series s ON s.series_id = c.series_id " + "WHERE h.user_id = ? ");
-
-        List<Object> params = new ArrayList<>();
-        params.add(userId);
-
-        if (keyword != null && !keyword.isBlank()) {
-            sql.append("AND (s.title LIKE ? OR c.title LIKE ?) ");
-            params.add("%" + keyword + "%");
-            params.add("%" + keyword + "%");
-        }
-
-        sql.append("ORDER BY h.last_read_at DESC OFFSET ? ROWS FETCH NEXT ? ROWS ONLY");
-        params.add(offset);
-        params.add(pageSize);
-
-        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {
-            for (int i = 0; i < params.size(); i++) {
-                ps.setObject(i + 1, params.get(i));
-            }
-            try (ResultSet rs = ps.executeQuery()) {
-                List<ChapterItemDTO> list = new ArrayList<>();
-                while (rs.next()) {
-                    ChapterItemDTO it = new ChapterItemDTO();
-                    it.setChapterId(rs.getInt("chapter_id"));
-                    it.setSeriesId(rs.getInt("series_id"));
-                    it.setSeriesTitle(rs.getString("series_title"));
-                    it.setChapterNumber(rs.getInt("chapter_number"));
-                    it.setChapterTitle(rs.getString("chapter_title"));
-                    it.setStatus(rs.getString("status"));
-                    it.setCoverImgUrl(rs.getString("cover_image_url"));
-                    Timestamp up = rs.getTimestamp("updated_at");
-                    it.setUpdatedAt(up != null ? up.toLocalDateTime() : null);
-                    Timestamp lr = rs.getTimestamp("last_read_at");
-                    it.setLastReadAt(lr != null ? lr.toLocalDateTime() : null);
-                    list.add(it);
-                }
-                return list;
-            }
-        }
-    }
-
-    /**
-     * Count the total number of chapters in a user's reading history with optional keyword filter.
-     *
-     * @param userId  the ID of the user
-     * @param keyword optional keyword to search in series or chapter titles
-     * @return the total count of chapters in the user's reading history matching the criteria
-     * @throws SQLException if a database access error occurs
-     */
-    public int countReadingHistoryChapters(int userId, String keyword) throws SQLException {
-        StringBuilder sql = new StringBuilder("SELECT COUNT(*) " + "FROM reading_history h " + "JOIN chapters c ON c.chapter_id = h.chapter_id " + "JOIN series s ON s.series_id = c.series_id " + "WHERE h.user_id = ? ");
-
-        List<Object> params = new ArrayList<>();
-        params.add(userId);
-
-        if (keyword != null && !keyword.isBlank()) {
-            sql.append("AND (s.title LIKE ? OR c.title LIKE ?) ");
-            params.add("%" + keyword + "%");
-            params.add("%" + keyword + "%");
-        }
-
-        try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {
-            for (int i = 0; i < params.size(); i++) {
-                ps.setObject(i + 1, params.get(i));
-            }
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? rs.getInt(1) : 0;
-            }
-        }
-    }
-
-    /**
-     * Get the latest chapter number of a series.
-     *
-     * @param seriesId ID of the series.
-     * @return number of the latest chapter. If no chapters exist, returns 0.
-     */
-    public int getLatestChapterNumber(int seriesId) throws SQLException {
-        String sql = "SELECT MAX(chapter_number) FROM chapters WHERE series_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return rs.getInt(1);
-                }
-            }
-        }
-        return 0;
-    }
-
-
-
-    /**
-     * Add a new chapter and return the Chapter object with the generated ID.
-     *
-     * @param chapter the Chapter object to add (without chapterId)
-     * @return the Chapter object with the generated chapterId, or null if insertion failed
-     */
-    public Chapter addChapter(Chapter chapter) throws SQLException {
-        String sql = "INSERT INTO chapters (series_id, chapter_number, title, content, status, created_at, updated_at) " + "VALUES (?, ?, ?, ?, ?, GETDATE(), GETDATE())";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
-            ps.setInt(1, chapter.getSeriesId());
-            ps.setInt(2, chapter.getChapterNumber());
-            ps.setString(3, chapter.getTitle());
-            ps.setString(4, chapter.getContent());
-            ps.setString(5, chapter.getStatus());
-
-            int affectedRows = ps.executeUpdate();
-
-            if (affectedRows > 0) {
-                try (ResultSet generatedKeys = ps.getGeneratedKeys()) {
-                    if (generatedKeys.next()) {
-                        chapter.setChapterId(generatedKeys.getInt(1));
-                        return chapter;
-                    }
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Find an approved chapter by its ID.
-     *
-     * @param chapterId the ID of the chapter
-     * @return the Chapter object if found and approved, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findApprovedById(int chapterId) throws SQLException {
-        String sql = """
-                    SELECT * FROM chapters
-                    WHERE chapter_id = ? AND is_deleted = 0 AND status = 'approved'
-                """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, chapterId);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? map(rs) : null;
-            }
-        }
-    }
-
-    /**
-     * Find an approved chapter by its series ID and chapter number.
-     *
-     * @param seriesId      the ID of the series
-     * @param chapterNumber the chapter number within the series
-     * @return the Chapter object if found and approved, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findApprovedBySeriesAndNumber(int seriesId, int chapterNumber) throws SQLException {
-        String sql = """
-                    SELECT * FROM chapters
-                    WHERE series_id = ? AND chapter_number = ? AND is_deleted = 0 AND status = 'approved'
-                """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, chapterNumber);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? map(rs) : null;
-            }
-        }
-    }
-
-    /**
-     * Find the next approved chapter in a series after the given chapter number.
-     *
-     * @param seriesId      the ID of the series
-     * @param currentNumber the current chapter number
-     * @return the next approved Chapter object if found, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findPrevApproved(int seriesId, int currentNumber) throws SQLException {
-        String sql = """
-                    SELECT TOP 1 * FROM chapters
-                    WHERE series_id = ? AND is_deleted = 0 AND status = 'approved'
-                      AND chapter_number < ?
-                    ORDER BY chapter_number DESC
-                """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, currentNumber);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? map(rs) : null;
-            }
-        }
-    }
-
-    /**
-     * Find the next approved chapter in a series after the current chapter number.
-     *
-     * @param seriesId      the ID of the series
-     * @param currentNumber the current chapter number
-     * @return the next approved Chapter object if found, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findNextApproved(int seriesId, int currentNumber) throws SQLException {
-        String sql = """
-                    SELECT TOP 1 * FROM chapters
-                    WHERE series_id = ? AND is_deleted = 0 AND status = 'approved'
-                      AND chapter_number > ?
-                    ORDER BY chapter_number ASC
-                """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, currentNumber);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? map(rs) : null;
-            }
-        }
-    }
-
-    /**
-     * Map the current row of the ResultSet to a Chapter object.
-     *
-     * @param rs the ResultSet positioned at the desired row
-     * @return a Chapter object populated with data from the ResultSet
-     * @throws SQLException if a database access error occurs
-     */
-    private Chapter map(ResultSet rs) throws SQLException {
-        Chapter c = new Chapter();
-
-        c.setChapterId(rs.getInt("chapter_id"));
-        c.setSeriesId(rs.getInt("series_id"));
-        c.setChapterNumber(rs.getInt("chapter_number"));
-        c.setTitle(rs.getString("title"));
-        c.setContent(rs.getString("content"));
-        c.setStatus(rs.getString("status"));
-        c.setDeleted(rs.getBoolean("is_deleted"));
-        Timestamp cr = rs.getTimestamp("created_at");
-        Timestamp up = rs.getTimestamp("updated_at");
-        c.setCreatedAt(cr != null ? cr.toLocalDateTime() : LocalDateTime.now());
-        c.setUpdatedAt(up != null ? up.toLocalDateTime() : LocalDateTime.now());
-        return c;
-    }
-
-    /**
-     * Find a chapter by its ID if it is not marked as deleted.
-     *
-     * @param chapterId the ID of the chapter
-     * @return the Chapter object if found and not deleted, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findByIdIfNotDeleted(int chapterId) throws SQLException {
-        String sql = "SELECT * FROM chapters WHERE chapter_id = ? AND is_deleted = 0";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, chapterId);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? map(rs) : null;
-            }
-        }
-    }
-
-    /**
-     * Find a chapter by its series ID and chapter number if it is not marked as deleted.
-     *
-     * @param seriesId      the ID of the series
-     * @param chapterNumber the chapter number within the series
-     * @return the Chapter object if found and not deleted, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Chapter findBySeriesAndNumberIfNotDeleted(int seriesId, int chapterNumber) throws SQLException {
-        String sql = """
-                    SELECT * FROM chapters
-                    WHERE series_id = ? AND chapter_number = ? AND is_deleted = 0
-                """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, chapterNumber);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? map(rs) : null;
-            }
-        }
-    }
-
-    public int countChapterBySeriesId(int seriesId) throws SQLException {
-        String sql = "SELECT COUNT(*) FROM chapters WHERE series_id = ? AND is_deleted = 0";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? rs.getInt(1) : 0;
-            }
-        }
-    }
-
-
-    public List<Chapter> findChapterBySeriesId(int seriesId) throws SQLException {
-        String sql = "SELECT * FROM chapters WHERE series_id = ? AND is_deleted = 0";
-        List<Chapter> chapterList = new ArrayList<>();
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                while (rs.next()) {
-                chapterList.add(extractChapterFromResultSet(rs));
-                }
-            }
-            return chapterList;
-        }
-    }
-
-    /**
-     * Retrieves the next chapter in a series based on the chapter index.
-     *
-     * @param seriesId     the ID of the series
-     * @param chapterNumber the index of the current chapter
-     * @return the next Chapter object if it exists, or null if there is no next
-     *         chapter.
-     * @throws SQLException If a database access error occurs.
-     */
-    public Chapter getNextChapter(int seriesId, int chapterNumber) throws SQLException {
-        String sql = "SELECT TOP 1 * FROM Chapters WHERE series_id = ? AND chapter_number > ? ORDER BY chapter_number ";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, chapterNumber);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return extractChapterFromResultSet(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Retrieves the previous chapter in a series based on the chapter index.
-     *
-     * @param seriesId     the ID of the series
-     * @param chapterNumber the index of the current chapter
-     * @return the previous Chapter object if it exists, or null if there is no
-     *         previous chapter.
-     * @throws SQLException If a database access error occurs.
-     */
-    public Chapter getPreviousChapter(int seriesId, int chapterNumber) throws SQLException {
-        String sql = "SELECT TOP 1 * FROM Chapters WHERE series_id = ? AND chapter_number < ? ORDER BY chapter_number DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, chapterNumber);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return extractChapterFromResultSet(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-
-    /**
-     * Get the latest chapter number of a series.
-     *
-     * @param seriesId ID of the series.
-     * @return number of the latest chapter. If no chapters exist, returns 0.
-     */
-    public int getFirstChapterNumber(int seriesId) throws SQLException {
-        String sql = "SELECT MIN(chapter_number) FROM chapters WHERE series_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return rs.getInt(1);
-                }
-            }
-        }
-        return 0;
-    }
-    /**
-     * Extract a Chapter object from the current row of the ResultSet.
-     *
-     * @param rs the ResultSet positioned at the desired row
-     * @return a Chapter object populated with data from the ResultSet
-     * @throws SQLException if a database access error occurs
-     */
-    private Chapter extractChapterFromResultSet(ResultSet rs) throws SQLException {
-        Chapter chapter = new Chapter();
-        chapter.setSeriesId(rs.getInt("series_id"));
-        chapter.setChapterId(rs.getInt("chapter_id"));
-        chapter.setChapterNumber(rs.getInt("chapter_number"));
-        chapter.setTitle(rs.getString("title"));
-        chapter.setContent(rs.getString("content"));
-        chapter.setStatus(rs.getString("status"));
-        chapter.setDeleted(rs.getBoolean("is_deleted"));
-        chapter.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
-        chapter.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
-        return chapter;
-    }
-}
Index: src/main/java/dao/PointHistoryDAO.java
===================================================================
diff --git a/src/main/java/dao/PointHistoryDAO.java b/src/main/java/dao/PointHistoryDAO.java
deleted file mode 100644
--- a/src/main/java/dao/PointHistoryDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,127 +0,0 @@
-package dao;
-
-import model.PointHistory;
-import java.sql.*;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class PointHistoryDAO {
-    private final Connection conn;
-
-    public PointHistoryDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    // ===========================================
-    // 1. Insert new record
-    // ===========================================
-    public boolean insert(PointHistory history) throws SQLException {
-        String sql = """
-            INSERT INTO point_history (user_id, point_change, reason, reference_type, reference_id, created_at)
-            VALUES (?, ?, ?, ?, ?, ?)
-            """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, history.getUserId());
-            ps.setInt(2, history.getPointChange());
-            ps.setString(3, history.getReason());
-            ps.setString(4, history.getReferenceType());
-            if (history.getReferenceId() != 0) {
-                ps.setInt(5, history.getReferenceId());
-            } else {
-                ps.setNull(5, Types.INTEGER);
-            }
-            ps.setTimestamp(6, Timestamp.valueOf(
-                    history.getCreatedAt() != null ? history.getCreatedAt() : LocalDateTime.now()
-            ));
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    // ===========================================
-    // 2. Get record by ID
-    // ===========================================
-    public PointHistory getById(int historyId) throws SQLException {
-        String sql = "SELECT * FROM point_history WHERE history_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, historyId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return extractFromResultSet(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    // ===========================================
-    // 3. Get all records
-    // ===========================================
-    public List<PointHistory> getAll() throws SQLException {
-        List<PointHistory> list = new ArrayList<>();
-        String sql = "SELECT * FROM point_history ORDER BY created_at DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql);
-             ResultSet rs = ps.executeQuery()) {
-            while (rs.next()) {
-                list.add(extractFromResultSet(rs));
-            }
-        }
-        return list;
-    }
-
-    // ===========================================
-    // 4. Get records by User ID
-    // ===========================================
-    public List<PointHistory> getByUserId(int userId) throws SQLException {
-        List<PointHistory> list = new ArrayList<>();
-        String sql = "SELECT * FROM point_history WHERE user_id = ? ORDER BY created_at DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            try (ResultSet rs = ps.executeQuery()) {
-                while (rs.next()) {
-                    list.add(extractFromResultSet(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    // ===========================================
-    // 5. Delete by ID
-    // ===========================================
-    public boolean delete(int historyId) throws SQLException {
-        String sql = "DELETE FROM point_history WHERE history_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, historyId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    // ===========================================
-    // 6. Delete all by user_id (nếu cần thủ công)
-    // ===========================================
-    public boolean deleteByUserId(int userId) throws SQLException {
-        String sql = "DELETE FROM point_history WHERE user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    // ===========================================
-    // Helper: convert ResultSet -> PointHistory
-    // ===========================================
-    private PointHistory extractFromResultSet(ResultSet rs) throws SQLException {
-        PointHistory ph = new PointHistory();
-        ph.setHistoryId(rs.getInt("history_id"));
-        ph.setUserId(rs.getInt("user_id"));
-        ph.setPointChange(rs.getInt("point_change"));
-        ph.setReason(rs.getString("reason"));
-        ph.setReferenceType(rs.getString("reference_type"));
-        int refId = rs.getInt("reference_id");
-        ph.setReferenceId(rs.wasNull() ? 0 : refId);
-        Timestamp ts = rs.getTimestamp("created_at");
-        ph.setCreatedAt(ts != null ? ts.toLocalDateTime() : null);
-        return ph;
-    }
-}
Index: src/main/java/dao/UserDAO.java
===================================================================
diff --git a/src/main/java/dao/UserDAO.java b/src/main/java/dao/UserDAO.java
deleted file mode 100644
--- a/src/main/java/dao/UserDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,196 +0,0 @@
-package dao;
-
-import model.User;
-
-import java.sql.*;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class UserDAO {
-    private final Connection conn;
-
-    public UserDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    // Lấy toàn bộ user chưa bị xóa
-    public List<User> getAll() throws SQLException {
-        List<User> users = new ArrayList<>();
-        String sql = "SELECT * FROM users WHERE is_deleted = 0";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                users.add(mapResultSetToUser(rs));
-            }
-        }
-        return users;
-    }
-
-    // Tìm user theo ID
-    public User findById(int id) throws SQLException {
-        String sql = "SELECT * FROM users WHERE user_id = ? AND is_deleted = 0";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToUser(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    // Thêm user mới
-    public boolean insert(User user) throws SQLException {
-        String sql = """
-                INSERT INTO users (username, full_name, bio, email, password_hash, role, 
-                                   is_verified, is_deleted, status, points, created_at, updated_at)
-                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
-                """;
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, user.getUsername());
-            stmt.setString(2, user.getFullName());
-            stmt.setString(3, user.getBio());
-            stmt.setString(4, user.getEmail());
-            stmt.setString(5, user.getPasswordHash());
-            stmt.setString(6, user.getRole());
-            stmt.setBoolean(7, user.isVerified());
-            stmt.setBoolean(8, user.isDeleted());
-            stmt.setString(9, user.getStatus());
-            stmt.setInt(10, user.getPoints());
-            stmt.setTimestamp(11, Timestamp.valueOf(user.getCreatedAt() != null ? user.getCreatedAt() : LocalDateTime.now()));
-            stmt.setTimestamp(12, Timestamp.valueOf(user.getUpdatedAt() != null ? user.getUpdatedAt() : LocalDateTime.now()));
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Cập nhật thông tin user
-    public boolean update(User user) throws SQLException {
-        String sql = """
-                UPDATE users
-                SET username = ?, full_name = ?, bio = ?, email = ?, password_hash = ?, 
-                    role = ?, is_verified = ?, is_deleted = ?, status = ?, points = ?, updated_at = ?
-                WHERE user_id = ? AND is_deleted = 0
-                """;
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, user.getUsername());
-            stmt.setString(2, user.getFullName());
-            stmt.setString(3, user.getBio());
-            stmt.setString(4, user.getEmail());
-            stmt.setString(5, user.getPasswordHash());
-            stmt.setString(6, user.getRole());
-            stmt.setBoolean(7, user.isVerified());
-            stmt.setBoolean(8, user.isDeleted());
-            stmt.setString(9, user.getStatus());
-            stmt.setInt(10, user.getPoints());
-            stmt.setTimestamp(11, Timestamp.valueOf(LocalDateTime.now())); // cập nhật thời gian sửa đổi
-            stmt.setInt(12, user.getUserId());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Xóa mềm user (chuyển cờ is_deleted = 1)
-    public boolean delete(int id) throws SQLException {
-        String sql = "UPDATE users SET is_deleted = 1, status = 'inactive', updated_at = GETDATE() WHERE user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Tìm theo tên người dùng
-    public List<User> findByName(String name) throws SQLException {
-        List<User> users = new ArrayList<>();
-        String sql = "SELECT * FROM users WHERE username LIKE ? AND is_deleted = 0 AND role = 'author'";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, "%" + name + "%");
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    users.add(mapResultSetToUser(rs));
-                }
-            }
-        }
-        return users;
-    }
-
-    // Lấy top người dùng theo điểm
-    public List<User> selectTopUserPoints(int limit) throws SQLException {
-        List<User> users = new ArrayList<>();
-        String sql = "SELECT TOP (?) * FROM users WHERE is_deleted = 0 AND role = 'reader' ORDER BY points DESC";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, limit);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    users.add(mapResultSetToUser(rs));
-                }
-            }
-        }
-        return users;
-    }
-
-    /**
-     * Update user role to 'author' by user ID.
-     *
-     * @param userId The ID of the user to update.
-     * @return true if the update was successful, false otherwise.
-     * @throws SQLException           If a database access error occurs.
-     * @throws ClassNotFoundException If the JDBC driver class is not found.
-     */
-    public boolean updateUserRoleToAuthor(int userId) throws SQLException, ClassNotFoundException {
-        String sql = "UPDATE Users SET role = 'author' WHERE id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            int rowsAffected = ps.executeUpdate();
-            return rowsAffected > 0;
-        }
-    }
-    /**
-     * Find user by username for authentication
-     *
-     * @return User object or null if not found
-     */
-    public User findByUsername(String username) throws SQLException {
-        String sql = "SELECT * FROM users WHERE username = ?";
-        User user = null;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setString(1, username);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    user = new User();
-                    user.setUserId(rs.getInt("user_id"));
-                    user.setUsername(rs.getString("username"));
-                    user.setEmail(rs.getString("email"));
-                    user.setRole(rs.getString("role"));
-                    // Set other user properties as needed
-                }
-            }
-        }
-        return user;
-    }
-
-    // Hàm map dữ liệu từ ResultSet sang đối tượng User
-    private User mapResultSetToUser(ResultSet rs) throws SQLException {
-        User user = new User();
-        user.setUserId(rs.getInt("user_id"));
-        user.setUsername(rs.getString("username"));
-        user.setFullName(rs.getString("full_name"));
-        user.setBio(rs.getString("bio"));
-        user.setEmail(rs.getString("email"));
-        user.setPasswordHash(rs.getString("password_hash"));
-        user.setRole(rs.getString("role"));
-        user.setVerified(rs.getBoolean("is_verified"));
-        user.setDeleted(rs.getBoolean("is_deleted"));
-        user.setStatus(rs.getString("status"));
-        user.setPoints(rs.getInt("points"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        Timestamp updated = rs.getTimestamp("updated_at");
-        user.setCreatedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-        user.setUpdatedAt(updated != null ? updated.toLocalDateTime() : LocalDateTime.now());
-
-        return user;
-    }
-}
Index: src/main/java/dao/CategoryDAO.java
===================================================================
diff --git a/src/main/java/dao/CategoryDAO.java b/src/main/java/dao/CategoryDAO.java
deleted file mode 100644
--- a/src/main/java/dao/CategoryDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,165 +0,0 @@
-package dao;
-
-import model.Category;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * DAO class for managing 'categories' table.
- * Includes CRUD and find methods.
- */
-public class CategoryDAO {
-    private final Connection conn;
-
-    public CategoryDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Get all category records.
-     */
-    public List<Category> getAll() throws SQLException {
-        List<Category> list = new ArrayList<>();
-        String sql = "SELECT * FROM categories";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-
-            while (rs.next()) {
-                list.add(mapResultSetToCategory(rs));
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Find category by ID.
-     */
-    public Category findById(int id) throws SQLException {
-        String sql = "SELECT * FROM categories WHERE category_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToCategory(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Insert a new category.
-     */
-    public boolean insert(Category category) throws SQLException {
-        String sql = "INSERT INTO categories (name, description) VALUES (?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, category.getName());
-            stmt.setString(2, category.getDescription());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Update an existing category.
-     */
-    public boolean update(Category category) throws SQLException {
-        String sql = "UPDATE categories SET name = ?, description = ? WHERE category_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, category.getName());
-            stmt.setString(2, category.getDescription());
-            stmt.setInt(3, category.getCategoryId());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Delete a category by ID.
-     */
-    public boolean delete(int id) throws SQLException {
-        String sql = "DELETE FROM categories WHERE category_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public List<Category> getCategoryBySeriesId(int seriesId) throws SQLException {
-        List<Category> listCategory = new ArrayList<>();
-        String sql = "SELECT * FROM categories c JOIN series_categories sc ON c.category_id = sc.category_id WHERE sc.series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    listCategory.add(mapResultSetToCategory(rs));
-                }
-            }
-            return listCategory;
-        }
-    }
-
-    public boolean matchGenres(int seriesId, List<String> genres) throws SQLException {
-        if (genres == null || genres.isEmpty()) return true;
-
-        String placeholders = String.join(",", genres.stream().map(g -> "?").toArray(String[]::new));
-
-        String sql = "SELECT COUNT(*) FROM series_categories sc " +
-                "JOIN categories c ON sc.category_id = c.category_id " +
-                "WHERE sc.series_id = ? AND c.name IN (" + placeholders + ")";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            for (int i = 0; i < genres.size(); i++) {
-                ps.setString(i + 2, genres.get(i));
-            }
-
-            ResultSet rs = ps.executeQuery();
-            if (rs.next()) {
-                return rs.getInt(1) > 0;
-            }
-        }
-        return false;
-    }
-
-    public List<Category> getCategoryTop(int limit) throws SQLException {
-        List<Category> list = new ArrayList<>();
-        String sql = "SELECT TOP " + limit + """
-                c.category_id,
-                        c.name,
-                        c.description,
-                        COUNT(sc.series_id) AS total_series
-                FROM
-                categories AS c
-                INNER JOIN
-                series_categories AS sc ON c.category_id = sc.category_id
-                INNER JOIN
-                series AS s ON sc.series_id = s.series_id
-                GROUP BY
-                c.category_id, c.name, c.description
-                ORDER BY
-                total_series DESC;""";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToCategory(rs));
-            }
-        }
-        return list;
-    }
-    /**
-     * Helper: Map a ResultSet row into a Category object.
-     */
-    private Category mapResultSetToCategory(ResultSet rs) throws SQLException {
-        Category category = new Category();
-        category.setCategoryId(rs.getInt("category_id"));
-        category.setName(rs.getString("name"));
-        category.setDescription(rs.getString("description"));
-        return category;
-    }
-}
Index: src/main/java/dao/SeriesAuthorDAO.java
===================================================================
diff --git a/src/main/java/dao/SeriesAuthorDAO.java b/src/main/java/dao/SeriesAuthorDAO.java
deleted file mode 100644
--- a/src/main/java/dao/SeriesAuthorDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,219 +0,0 @@
-package dao;
-
-import model.SeriesAuthor;
-import model.User;
-
-import java.sql.PreparedStatement;
-
-import java.sql.Connection;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * SeriesAuthorDAO class provides CRUD operations for SeriesAuthor entities in the database.
- *
- * @author KToan, HaiDD-dev
- */
-public class SeriesAuthorDAO {
-    private final Connection conn;
-
-    public SeriesAuthorDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Adds a new SeriesAuthor record to the database.
-     *
-     * @param sa the SeriesAuthor object to be added
-     * @return true if the record was added successfully, false otherwise
-     */
-    public boolean add(SeriesAuthor sa) throws SQLException {
-        String sql = "INSERT INTO series_author (series_id, user_id, added_at) VALUES (?, ?, ?)";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, sa.getSeriesId());
-            ps.setInt(2, sa.getAuthorId());
-            ps.setTimestamp(3, Timestamp.valueOf(sa.getAddedAt() != null ? sa.getAddedAt() : LocalDateTime.now()));
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Finds a SeriesAuthor record by series ID and user ID.
-     *
-     * @param seriesId the ID of the series
-     * @param userId   the ID of the user
-     * @return the SeriesAuthor object if found, null otherwise
-     */
-    public SeriesAuthor findById(int seriesId, int userId) throws SQLException {
-        String sql = "SELECT * FROM series_author WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, userId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToSeriesAuthor(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Retrieves all SeriesAuthor records from the database.
-     *
-     * @return a list of all SeriesAuthor objects
-     */
-    public List<SeriesAuthor> findAll() throws SQLException {
-        String sql = "SELECT * FROM series_author";
-        List<SeriesAuthor> list = new ArrayList<>();
-        try (PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToSeriesAuthor(rs));
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Updates an existing SeriesAuthor record in the database.
-     *
-     * @param sa the SeriesAuthor object with updated information
-     * @return true if the record was updated successfully, false otherwise
-     */
-    public boolean update(SeriesAuthor sa) throws SQLException {
-        String sql = "UPDATE series_author SET added_at = ? WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setTimestamp(1, Timestamp.valueOf(sa.getAddedAt()));
-            ps.setInt(2, sa.getSeriesId());
-            ps.setInt(3, sa.getAuthorId());
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Deletes a SeriesAuthor record from the database.
-     *
-     * @param seriesId the ID of the series
-     * @param userId   the ID of the user
-     * @return true if the record was deleted successfully, false otherwise
-     */
-    public boolean delete(int seriesId, int userId) throws SQLException {
-        String sql = "DELETE FROM series_author WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, userId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Checks if a user is an author of a specific series.
-     *
-     * @param userId   the ID of the user
-     * @param seriesId the ID of the series
-     * @return true if the user is an author of the series, false otherwise
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean isUserAuthorOfSeries(int userId, int seriesId) throws SQLException {
-        String sql = "SELECT COUNT(1) FROM series_author WHERE user_id = ? AND series_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            ps.setInt(2, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    return rs.getInt(1) <= 0;
-                }
-            }
-        }
-        return false;
-    }
-
-    public List<String> authorsOfSeries(int seriesId) throws SQLException {
-        String sql = "SELECT DISTINCT username FROM users u JOIN series_author sa ON u.user_id = sa.user_id AND series_id = ?";
-        List<String> authorsName = new ArrayList<>();
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                while (rs.next()) {
-                    authorsName.add(rs.getString("username"));
-                }
-                return authorsName;
-            }
-        }
-    }
-
-    /**
-     * Finds all users associated with a given series.
-     *
-     * @param seriesId The ID of the series.
-     * @return A list of User objects.
-     */
-    public List<User> findUsersBySeriesId(int seriesId) throws SQLException {
-        List<User> users = new ArrayList<>();
-        // Assumes a JOIN between SeriesAuthors and Users tables
-        String sql = "SELECT u.* FROM Users u JOIN series_author sa ON u.user_id = sa.user_id WHERE sa.series_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                while (rs.next()) {
-                    User user = new User();
-                    user.setUserId(rs.getInt("user_id"));
-                    user.setUsername(rs.getString("username"));
-                    user.setEmail(rs.getString("email"));
-                    users.add(user);
-                }
-            }
-        }
-        return users;
-    }
-
-    /**
-     * Adds an author to a series.
-     *
-     * @param seriesId The ID of the series.
-     * @param userId   The ID of the user to add.
-     */
-    public void addAuthorToSeries(int seriesId, int userId) throws SQLException {
-        String sql = "INSERT INTO series_author (series_id, user_id) VALUES (?, ?)";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, userId);
-            ps.executeUpdate();
-        }
-    }
-
-    /**
-     * Removes an author from a series.
-     *
-     * @param seriesId The ID of the series.
-     * @param userId   The ID of the user to remove.
-     */
-    public void removeAuthorFromSeries(int seriesId, int userId) throws SQLException {
-        String sql = "DELETE FROM series_author WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, userId);
-            ps.executeUpdate();
-        }
-    }
-
-    /**
-     * Utility method to map a ResultSet row to a SeriesAuthor object.
-     *
-     * @param rs the ResultSet to map
-     * @return the mapped SeriesAuthor object
-     */
-    private SeriesAuthor mapResultSetToSeriesAuthor(ResultSet rs) throws SQLException {
-        SeriesAuthor seriesAuthor = new SeriesAuthor();
-        seriesAuthor.setAuthorId(rs.getInt("user_id"));
-        seriesAuthor.setSeriesId(rs.getInt("series_id"));
-        Timestamp created = rs.getTimestamp("created_at");
-        seriesAuthor.setAddedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-        return seriesAuthor;
-    }
-}
-
Index: src/main/java/dao/BadgeDAO.java
===================================================================
diff --git a/src/main/java/dao/BadgeDAO.java b/src/main/java/dao/BadgeDAO.java
deleted file mode 100644
--- a/src/main/java/dao/BadgeDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,95 +0,0 @@
-package dao;
-
-import model.Badge;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class BadgeDAO {
-    private final Connection conn;
-
-    public BadgeDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    public List<Badge> getAll() throws SQLException {
-        List<Badge> list = new ArrayList<>();
-        String sql = "SELECT * FROM badges";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-
-            while (rs.next()) {
-                list.add(mapResultSetToBadges(rs));
-            }
-        }
-        return list;
-    }
-
-    public Badge findById(int badgeId) throws SQLException {
-        String sql = "SELECT * FROM badges WHERE badge_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, badgeId);
-
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToBadges(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    public boolean insert(Badge badge) throws SQLException {
-        String sql = "INSERT INTO badges (icon_url, name, description, created_at) VALUES (?, ?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, badge.getIconUrl());
-            stmt.setString(2, badge.getName());
-            stmt.setString(3, badge.getDescription());
-            stmt.setTimestamp(4, Timestamp.valueOf(
-                    badge.getCreatedAt() != null ? badge.getCreatedAt() : LocalDateTime.now()
-            ));
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public boolean update(Badge badge) throws SQLException {
-        String sql = "UPDATE badges SET icon_url = ?, name = ?, description = ?, created_at = ? WHERE badge_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setString(1, badge.getIconUrl());
-            stmt.setString(2, badge.getName());
-            stmt.setString(3, badge.getDescription());
-            stmt.setTimestamp(4, Timestamp.valueOf(badge.getCreatedAt()));
-            stmt.setInt(5, badge.getBadgeId());
-
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public boolean delete(int badgeId) throws SQLException {
-        String sql = "DELETE FROM badges WHERE badge_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, badgeId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    private Badge mapResultSetToBadges(ResultSet rs) throws SQLException {
-        Badge badge = new Badge();
-        badge.setBadgeId(rs.getInt("badge_id"));
-        badge.setIconUrl(rs.getString("icon_url"));
-        badge.setName(rs.getString("name"));
-        badge.setDescription(rs.getString("description"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        badge.setCreatedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-
-        return badge;
-    }
-}
Index: src/main/java/dao/SeriesCategoriesDAO.java
===================================================================
diff --git a/src/main/java/dao/SeriesCategoriesDAO.java b/src/main/java/dao/SeriesCategoriesDAO.java
deleted file mode 100644
--- a/src/main/java/dao/SeriesCategoriesDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,137 +0,0 @@
-package dao;
-
-import java.sql.*;
-import java.util.ArrayList;
-import java.util.List;
-
-import model.SeriesCategories;
-
-/**
- * DAO for series_categories table.
- * Uses external Connection for better transaction control.
- */
-public class SeriesCategoriesDAO {
-    private final Connection conn;
-    public SeriesCategoriesDAO(Connection conn) {
-        this.conn = conn;
-    }
-    /**
-     * Get all series-category mappings.
-     *
-     * @return List of SeriesCategory objects.
-     * @throws SQLException if any SQL error occurs.
-     */
-    public List<SeriesCategories> getAll() throws SQLException {
-        List<SeriesCategories> list = new ArrayList<>();
-        String sql = "SELECT series_id, category_id FROM series_categories";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql);
-             ResultSet rs = ps.executeQuery()) {
-
-            while (rs.next()) {
-                SeriesCategories sc = new SeriesCategories();
-                sc.setSeriesId(rs.getInt("series_id"));
-                sc.setCategoryId(rs.getInt("category_id"));
-                list.add(sc);
-            }
-        }
-
-        return list;
-    }
-
-    /**
-     * Find a specific series-category record.
-     *
-     * @param seriesId   Series ID.
-     * @param categoryId Category ID.
-     * @return SeriesCategory or null if not found.
-     * @throws SQLException if any SQL error occurs.
-     */
-    public SeriesCategories findById( int seriesId, int categoryId) throws SQLException {
-        String sql = "SELECT series_id, category_id FROM series_categories WHERE series_id = ? AND category_id = ?";
-        SeriesCategories sc = null;
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, categoryId);
-
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    sc = new SeriesCategories();
-                    sc.setSeriesId(rs.getInt("series_id"));
-                    sc.setCategoryId(rs.getInt("category_id"));
-                }
-            }
-        }
-
-        return sc;
-    }
-
-    /**
-     * Insert a new series-category record.
-     *
-     * @param sc   The SeriesCategory object to insert.
-     * @return true if inserted successfully.
-     * @throws SQLException if any SQL error occurs.
-     */
-    public boolean insert( SeriesCategories sc) throws SQLException {
-        String sql = "INSERT INTO series_categories (series_id, category_id) VALUES (?, ?)";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, sc.getSeriesId());
-            ps.setInt(2, sc.getCategoryId());
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Update an existing record.
-     *
-     * @param oldSeriesId   Old series ID.
-     * @param oldCategoryId Old category ID.
-     * @param newData       New data to update.
-     * @return true if updated successfully.
-     * @throws SQLException if any SQL error occurs.
-     */
-    public boolean update( int oldSeriesId, int oldCategoryId, SeriesCategories newData) throws SQLException {
-        String sql = "UPDATE series_categories SET series_id = ?, category_id = ? WHERE series_id = ? AND category_id = ? ";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, newData.getSeriesId());
-            ps.setInt(2, newData.getCategoryId());
-            ps.setInt(3, oldSeriesId);
-            ps.setInt(4, oldCategoryId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Delete a record by seriesId and categoryId.
-     *
-     * @param seriesId   Series ID.
-     * @param categoryId Category ID.
-     * @return true if deleted successfully.
-     * @throws SQLException if any SQL error occurs.
-     */
-    public boolean delete( int seriesId, int categoryId) throws SQLException {
-        String sql = "DELETE FROM series_categories WHERE series_id = ? AND category_id = ?";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            ps.setInt(2, categoryId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    public int countSeriesByCategoryId(int categoryId) throws SQLException {
-        String sql = "SELECT COUNT(series_id) FROM series_categories WHERE category_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, categoryId);
-            ResultSet rs = ps.executeQuery();
-            if (rs.next()) {
-                return rs.getInt(1);
-            }
-        }
-        return 0;
-    }
-}
Index: .idea/encodings.xml
===================================================================
diff --git a/.idea/encodings.xml b/.idea/encodings.xml
deleted file mode 100644
--- a/.idea/encodings.xml	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="Encoding">
-    <file url="file://$PROJECT_DIR$/src/main/java" charset="UTF-8" />
-    <file url="file://$PROJECT_DIR$/src/main/resources" charset="UTF-8" />
-  </component>
-</project>
\ No newline at end of file
Index: src/main/java/dao/LikesDAO.java
===================================================================
diff --git a/src/main/java/dao/LikesDAO.java b/src/main/java/dao/LikesDAO.java
deleted file mode 100644
--- a/src/main/java/dao/LikesDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,160 +0,0 @@
-package dao;
-
-import model.Like;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Data Access Object for Likes
- *
- * @author KToan, HaiDD-dev
- */
-public class LikesDAO {
-    private final Connection conn;
-
-    public LikesDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Retrieves all Like records from the database.
-     *
-     * @return A list of all Like records.
-     * @throws SQLException If an SQL error occurs during the retrieval.
-     */
-    public List<Like> getAll() throws SQLException {
-        List<Like> list = new ArrayList<>();
-        String sql = "SELECT * FROM likes";
-        try (PreparedStatement stmt = conn.prepareStatement(sql); ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToLike(rs));
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Checks if a like exists for a given user and chapter.
-     *
-     * @param userId    The ID of the user.
-     * @param chapterId The ID of the chapter.
-     * @return true if the like exists, false otherwise.
-     * @throws SQLException If an SQL error occurs during the check.
-     */
-    public boolean exists(int userId, int chapterId) throws SQLException {
-        String sql = "SELECT 1 FROM likes WHERE user_id = ? AND chapter_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            stmt.setInt(2, chapterId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                return rs.next();
-            }
-        }
-    }
-
-    /**
-     * Inserts a new Like record into the database.
-     *
-     * @param like The Like object to insert.
-     * @return true if the insertion was successful, false otherwise.
-     * @throws SQLException If an SQL error occurs during the insertion.
-     */
-    public boolean insert(Like like) throws SQLException {
-        String sql = "INSERT INTO likes (user_id, chapter_id, liked_at) VALUES (?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, like.getUserId());
-            stmt.setInt(2, like.getChapterId());
-            stmt.setTimestamp(3, Timestamp.valueOf(like.getLikedAt() != null ? like.getLikedAt() : LocalDateTime.now()));
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Deletes a Like record from the database.
-     *
-     * @param userId    The ID of the user.
-     * @param chapterId The ID of the chapter.
-     * @return true if the deletion was successful, false otherwise.
-     * @throws SQLException If an SQL error occurs during the deletion.
-     */
-    public boolean delete(int userId, int chapterId) throws SQLException {
-        String sql = "DELETE FROM likes WHERE user_id = ? AND chapter_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            stmt.setInt(2, chapterId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Additional Methods
-     */
-    public List<Like> findByUser(int userId) throws SQLException {
-        List<Like> list = new ArrayList<>();
-        String sql = "SELECT * FROM likes WHERE user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToLike(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Counts the number of likes for a specific chapter.
-     *
-     * @param chapterId The ID of the chapter.
-     * @return The number of likes for the chapter.
-     * @throws SQLException If an SQL error occurs during the count.
-     */
-    public int countByChapter(int chapterId) throws SQLException {
-        String sql = "SELECT COUNT(*) FROM likes WHERE chapter_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, chapterId);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next() ? rs.getInt(1) : 0;
-            }
-        }
-    }
-
-    /**
-     * Checks if a specific user has liked a specific chapter.
-     *
-     * @param userId    The ID of the user.
-     * @param chapterId The ID of the chapter.
-     * @return true if the user has liked the chapter, false otherwise.
-     * @throws SQLException If an SQL error occurs during the check.
-     */
-    public boolean isLikedByUser(int userId, int chapterId) throws SQLException {
-        String sql = "SELECT 1 FROM likes WHERE user_id = ? AND chapter_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            ps.setInt(2, chapterId);
-            try (ResultSet rs = ps.executeQuery()) {
-                return rs.next();
-            }
-        }
-    }
-
-    /**
-     * Utility method to map ResultSet to Like object
-     */
-    private Like mapResultSetToLike(ResultSet rs) throws SQLException {
-        Like like = new Like();
-        like.setUserId(rs.getInt("user_id"));
-        like.setChapterId(rs.getInt("chapter_id"));
-        Timestamp ts = rs.getTimestamp("liked_at");
-        like.setLikedAt(ts != null ? ts.toLocalDateTime() : LocalDateTime.now());
-        return like;
-    }
-}
Index: src/main/java/model/Rating.java
===================================================================
diff --git a/src/main/java/model/Rating.java b/src/main/java/model/Rating.java
deleted file mode 100644
--- a/src/main/java/model/Rating.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,60 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Rating {
-    private int ratingValue;
-    private int userId;
-    private int seriesId;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-
-    public Rating(int ratingValue, int userId, int seriesId, LocalDateTime createdAt, LocalDateTime updatedAt) {
-        this.ratingValue = ratingValue;
-        this.userId = userId;
-        this.seriesId = seriesId;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-    }
-    public Rating(){}
-
-    public int getRatingValue() {
-        return ratingValue;
-    }
-
-    public void setRatingValue(int ratingValue) {
-        this.ratingValue = ratingValue;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public int getSeriesId() {
-        return seriesId;
-    }
-
-    public void setSeriesId(int seriesId) {
-        this.seriesId = seriesId;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-}
Index: src/main/java/dao/RatingDAO.java
===================================================================
diff --git a/src/main/java/dao/RatingDAO.java b/src/main/java/dao/RatingDAO.java
deleted file mode 100644
--- a/src/main/java/dao/RatingDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,159 +0,0 @@
-package dao;
-
-import model.Rating;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class RatingDAO {
-    private final Connection conn;
-
-    public RatingDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    private Rating mapResultSetToRating(ResultSet rs) throws SQLException {
-        Rating r = new Rating();
-        r.setSeriesId(rs.getInt("series_id"));
-        r.setUserId(rs.getInt("user_id"));
-        r.setRatingValue(rs.getByte("score"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        Timestamp updated = rs.getTimestamp("updated_at");
-        r.setCreatedAt(created != null ? created.toLocalDateTime() : null);
-        r.setUpdatedAt(updated != null ? updated.toLocalDateTime() : null);
-
-        return r;
-    }
-
-    public boolean insert(Rating rating) throws SQLException {
-        String sql = "INSERT INTO ratings (series_id, user_id, score, created_at, updated_at) VALUES (?, ?, ?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, rating.getSeriesId());
-            stmt.setInt(2, rating.getUserId());
-            stmt.setInt(3, rating.getRatingValue());
-            stmt.setTimestamp(4, Timestamp.valueOf(rating.getCreatedAt() != null ? rating.getCreatedAt() : LocalDateTime.now()));
-            stmt.setTimestamp(5, Timestamp.valueOf(rating.getUpdatedAt() != null ? rating.getUpdatedAt() : LocalDateTime.now()));
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public List<Rating> getAll() throws SQLException {
-        List<Rating> list = new ArrayList<>();
-        String sql = "SELECT * FROM ratings";
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToRating(rs));
-            }
-        }
-        return list;
-    }
-
-    public List<Rating> getByUserId(int userId) throws SQLException {
-        List<Rating> list = new ArrayList<>();
-        String sql = "SELECT * FROM ratings WHERE user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToRating(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    public List<Rating> getBySeriesId(int seriesId) throws SQLException {
-        List<Rating> list = new ArrayList<>();
-        String sql = "SELECT * FROM ratings WHERE series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToRating(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    public Rating findById(int seriesId, int userId) throws SQLException {
-        String sql = "SELECT * FROM ratings WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            stmt.setInt(2, userId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToRating(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    public boolean update(Rating rating) throws SQLException {
-        String sql = "UPDATE ratings SET score = ?, updated_at = ? WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, rating.getRatingValue());
-            stmt.setTimestamp(2, Timestamp.valueOf(LocalDateTime.now()));
-            stmt.setInt(3, rating.getSeriesId());
-            stmt.setInt(4, rating.getUserId());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public boolean delete(int seriesId, int userId) throws SQLException {
-        String sql = "DELETE FROM ratings WHERE series_id = ? AND user_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            stmt.setInt(2, userId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    public double getAverageRating(int seriesId) throws SQLException {
-        String sql = "SELECT AVG(CAST(score AS FLOAT)) AS avg_rating FROM ratings WHERE series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return rs.getDouble("avg_rating");
-                }
-            }
-        }
-        return 0.0;
-    }
-
-    public int getRatingCount(int seriesId) throws SQLException {
-        String sql = "SELECT COUNT(*) AS total FROM ratings WHERE series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return rs.getInt("total");
-                }
-            }
-        }
-        return 0;
-    }
-
-    public int getRatingSumBySeriesId(int seriesId) throws SQLException {
-        String sql = "SELECT SUM(score) AS total FROM ratings WHERE series_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, seriesId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return rs.getInt("total");
-                }
-            }
-        }
-        return 0;
-    }
-}
\ No newline at end of file
Index: src/main/java/model/BadgesUser.java
===================================================================
diff --git a/src/main/java/model/BadgesUser.java b/src/main/java/model/BadgesUser.java
deleted file mode 100644
--- a/src/main/java/model/BadgesUser.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,42 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class BadgesUser {
-    private int badgeId;
-    private int userId;
-    private LocalDateTime awardedAt;
-
-    public BadgesUser(int badgeId, int userId, LocalDateTime awardedAt) {
-        this.badgeId = badgeId;
-        this.userId = userId;
-        this.awardedAt = awardedAt;
-    }
-
-    public BadgesUser() {
-    }
-
-    public int getBadgeId() {
-        return badgeId;
-    }
-
-    public void setBadgeId(int badgeId) {
-        this.badgeId = badgeId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public LocalDateTime getAwardedAt() {
-        return awardedAt;
-    }
-
-    public void setAwardedAt(LocalDateTime awardedAt) {
-        this.awardedAt = awardedAt;
-    }
-}
Index: src/main/java/model/Staff.java
===================================================================
diff --git a/src/main/java/model/Staff.java b/src/main/java/model/Staff.java
deleted file mode 100644
--- a/src/main/java/model/Staff.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,91 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Staff {
-    private int staffId;
-    private String username;
-    private String passwordHash;
-    private String fullName;
-    private String role;
-    private boolean isDeleted;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-
-
-    public Staff(int staffId, String username, String passwordHash, String fullName, String role, boolean isDeleted, LocalDateTime createdAt, LocalDateTime updatedAt) {
-        this.staffId = staffId;
-        this.username = username;
-        this.passwordHash = passwordHash;
-        this.fullName = fullName;
-        this.role = role;
-        this.isDeleted = isDeleted;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-    }
-
-    public Staff() {}
-    public String getRole() {
-        return role;
-    }
-
-    public void setRole(String role) {
-        this.role = role;
-    }
-
-    public int getStaffId() {
-        return staffId;
-    }
-
-    public void setStaffId(int staffId) {
-        this.staffId = staffId;
-    }
-
-    public String getUsername() {
-        return username;
-    }
-
-    public void setUsername(String username) {
-        this.username = username;
-    }
-
-    public String getPasswordHash() {
-        return passwordHash;
-    }
-
-    public void setPasswordHash(String passwordHash) {
-        this.passwordHash = passwordHash;
-    }
-
-    public String getFullName() {
-        return fullName;
-    }
-
-    public void setFullName(String fullName) {
-        this.fullName = fullName;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public boolean isDeleted() {
-        return isDeleted;
-    }
-
-    public void setDeleted(boolean deleted) {
-        this.isDeleted = deleted;
-    }
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-
-}
Index: .idea/compiler.xml
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
deleted file mode 100644
--- a/.idea/compiler.xml	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,13 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="CompilerConfiguration">
-    <annotationProcessing>
-      <profile name="Maven default annotation processors profile" enabled="true">
-        <sourceOutputDir name="target/generated-sources/annotations" />
-        <sourceTestOutputDir name="target/generated-test-sources/test-annotations" />
-        <outputRelativeToContentRoot value="true" />
-        <module name="JoyLeeBook" />
-      </profile>
-    </annotationProcessing>
-  </component>
-</project>
\ No newline at end of file
Index: src/main/java/model/Category.java
===================================================================
diff --git a/src/main/java/model/Category.java b/src/main/java/model/Category.java
deleted file mode 100644
--- a/src/main/java/model/Category.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,38 +0,0 @@
-package model;
-
-public class Category {
-    private int categoryId;
-    private String name;
-    private String description;
-
-    public Category(int categoryId, String name, String description) {
-        this.categoryId = categoryId;
-        this.name = name;
-        this.description = description;
-    }
-
-    public Category() {}
-    public int getCategoryId() {
-        return categoryId;
-    }
-
-    public void setCategoryId(int categoryId) {
-        this.categoryId = categoryId;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getDescription() {
-        return description;
-    }
-
-    public void setDescription(String description) {
-        this.description = description;
-    }
-}
Index: src/main/java/model/ReadingHistory.java
===================================================================
diff --git a/src/main/java/model/ReadingHistory.java b/src/main/java/model/ReadingHistory.java
deleted file mode 100644
--- a/src/main/java/model/ReadingHistory.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,40 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class ReadingHistory {
-    private int userId;
-    private int chapterId;
-    private LocalDateTime lastReadAt;
-
-    public ReadingHistory(int userId, int chapterId, LocalDateTime lastReadAt) {
-        this.userId = userId;
-        this.chapterId = chapterId;
-        this.lastReadAt = lastReadAt;
-    }
-
-    public ReadingHistory() {}
-    public LocalDateTime getLastReadAt() {
-        return lastReadAt;
-    }
-
-    public void setLastReadAt(LocalDateTime lastReadAt) {
-        this.lastReadAt = lastReadAt;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public int getChapterId() {
-        return chapterId;
-    }
-
-    public void setChapterId(int chapterId) {
-        this.chapterId = chapterId;
-    }
-}
Index: .idea/.gitignore
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
deleted file mode 100644
--- a/.idea/.gitignore	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,8 +0,0 @@
-# Default ignored files
-/shelf/
-/workspace.xml
-# Editor-based HTTP Client requests
-/httpRequests/
-# Datasource local storage ignored files
-/dataSources/
-/dataSources.local.xml
Index: src/main/java/model/Badge.java
===================================================================
diff --git a/src/main/java/model/Badge.java b/src/main/java/model/Badge.java
deleted file mode 100644
--- a/src/main/java/model/Badge.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,82 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Badge {
-    private int badgeId;
-    private String name;
-    private String iconUrl;
-    private String description;
-    private LocalDateTime createdAt;
-    private String requirementType;
-    private String requirementValue;
-
-    public Badge(int badgeId, String name, String iconUrl, String description, LocalDateTime createdAt, String requirementType, String requirementValue) {
-        this.badgeId = badgeId;
-        this.name = name;
-        this.iconUrl = iconUrl;
-        this.description = description;
-        this.createdAt = createdAt;
-        this.requirementType = requirementType;
-        this.requirementValue = requirementValue;
-    }
-
-    public Badge() {
-    }
-
-    public int getBadgeId() {
-        return badgeId;
-    }
-
-    public void setBadgeId(int badgeId) {
-        this.badgeId = badgeId;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getIconUrl() {
-        return iconUrl;
-    }
-
-    public void setIconUrl(String iconUrl) {
-        this.iconUrl = iconUrl;
-    }
-
-    public String getDescription() {
-        return description;
-    }
-
-    public void setDescription(String description) {
-        this.description = description;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public String getRequirementType() {
-        return requirementType;
-    }
-
-    public void setRequirementType(String requirementType) {
-        this.requirementType = requirementType;
-    }
-
-    public String getRequirementValue() {
-        return requirementValue;
-    }
-
-    public void setRequirementValue(String requirementValue) {
-        this.requirementValue = requirementValue;
-    }
-}
Index: src/main/java/model/SavedSeries.java
===================================================================
diff --git a/src/main/java/model/SavedSeries.java b/src/main/java/model/SavedSeries.java
deleted file mode 100644
--- a/src/main/java/model/SavedSeries.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,41 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class SavedSeries {
-    private int seriesId;
-    private int userId;
-    private LocalDateTime savedAt;
-
-    public SavedSeries(int seriesId, int userId, LocalDateTime savedAt) {
-        this.seriesId = seriesId;
-        this.userId = userId;
-        this.savedAt = savedAt;
-    }
-
-    public SavedSeries() {}
-
-    public int getSeriesId() {
-        return seriesId;
-    }
-
-    public void setSeriesId(int seriesId) {
-        this.seriesId = seriesId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public LocalDateTime getSavedAt() {
-        return savedAt;
-    }
-
-    public void setSavedAt(LocalDateTime savedAt) {
-        this.savedAt = savedAt;
-    }
-}
Index: src/main/java/model/Series.java
===================================================================
diff --git a/src/main/java/model/Series.java b/src/main/java/model/Series.java
deleted file mode 100644
--- a/src/main/java/model/Series.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,111 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Series {
-    private int seriesId;
-    private String title;
-    private String description;
-    private String coverImgUrl;
-    private String status;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-    private int authorId;
-    private boolean isDeleted;
-    private int rating_points;
-
-    public Series(int seriesId, String title, String description, String coverImgUrl, String status, LocalDateTime createdAt, LocalDateTime updatedAt, int authorId, boolean isDeleted, int rating_points) {
-        this.seriesId = seriesId;
-        this.title = title;
-        this.description = description;
-        this.coverImgUrl = coverImgUrl;
-        this.status = status;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-        this.authorId = authorId;
-        this.isDeleted = isDeleted;
-        this.rating_points = rating_points;
-    }
-
-    public Series() {}
-
-    public int getSeriesId() {
-        return seriesId;
-    }
-
-    public void setSeriesId(int seriesId) {
-        this.seriesId = seriesId;
-    }
-
-    public String getTitle() {
-        return title;
-    }
-
-    public void setTitle(String title) {
-        this.title = title;
-    }
-
-    public String getDescription() {
-        return description;
-    }
-
-    public void setDescription(String description) {
-        this.description = description;
-    }
-
-    public String getCoverImgUrl() {
-        return coverImgUrl;
-    }
-
-    public void setCoverImgUrl(String coverImgUrl) {
-        this.coverImgUrl = coverImgUrl;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public void setStatus(String status) {
-        this.status = status;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-
-    public int getAuthorId() {
-        return authorId;
-    }
-
-    public void setAuthorId(int authorId) {
-        this.authorId = authorId;
-    }
-
-    public boolean isDeleted() {
-        return isDeleted;
-    }
-
-    public void setDeleted(boolean deleted) {
-        isDeleted = deleted;
-    }
-
-    public int getRating_points() {
-        return rating_points;
-    }
-
-    public void setRating_points(int rating_points) {
-        this.rating_points = rating_points;
-    }
-}
Index: src/main/java/dao/NotificationsDAO.java
===================================================================
diff --git a/src/main/java/dao/NotificationsDAO.java b/src/main/java/dao/NotificationsDAO.java
deleted file mode 100644
--- a/src/main/java/dao/NotificationsDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,134 +0,0 @@
-package dao;
-
-import model.Notification;
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.ArrayList;
-import java.util.List;
-
-public class NotificationsDAO {
-    private final Connection conn;
-
-    public NotificationsDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    // Lấy toàn bộ thông báo
-    public List<Notification> getAll() throws SQLException {
-        List<Notification> list = new ArrayList<>();
-        String sql = "SELECT * FROM notifications ORDER BY created_at DESC";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql);
-             ResultSet rs = stmt.executeQuery()) {
-            while (rs.next()) {
-                list.add(mapResultSetToNotification(rs));
-            }
-        }
-        return list;
-    }
-
-    // Tìm thông báo theo ID
-    public Notification findById(int id) throws SQLException {
-        String sql = "SELECT * FROM notifications WHERE notification_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, id);
-            try (ResultSet rs = stmt.executeQuery()) {
-                if (rs.next()) {
-                    return mapResultSetToNotification(rs);
-                }
-            }
-        }
-        return null;
-    }
-
-    // Lấy tất cả thông báo của một user
-    public List<Notification> findByUserId(int userId) throws SQLException {
-        List<Notification> list = new ArrayList<>();
-        String sql = "SELECT * FROM notifications WHERE user_id = ? ORDER BY created_at DESC";
-
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, userId);
-            try (ResultSet rs = stmt.executeQuery()) {
-                while (rs.next()) {
-                    list.add(mapResultSetToNotification(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    // Thêm thông báo mới
-    public boolean insert(Notification noti) throws SQLException {
-        String sql = "INSERT INTO notifications (user_id, type, title, message, is_read, url_redirect, created_at) " +
-                "VALUES (?, ?, ?, ?, ?, ?, ?)";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, noti.getUserId());
-            stmt.setString(2, noti.getType());
-            stmt.setString(3, noti.getTitle());
-            stmt.setString(4, noti.getMessage());
-            stmt.setBoolean(5, noti.isRead());
-            stmt.setString(6, noti.getUrlRedirect());
-            stmt.setTimestamp(7, Timestamp.valueOf(
-                    noti.getCreatedAt() != null ? noti.getCreatedAt() : LocalDateTime.now()
-            ));
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Cập nhật nội dung thông báo (hoặc trạng thái đã đọc)
-    public boolean update(Notification noti) throws SQLException {
-        String sql = "UPDATE notifications SET " +
-                "user_id = ?, type = ?, title = ?, message = ?, is_read = ?, url_redirect = ?, created_at = ? " +
-                "WHERE notification_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, noti.getUserId());
-            stmt.setString(2, noti.getType());
-            stmt.setString(3, noti.getTitle());
-            stmt.setString(4, noti.getMessage());
-            stmt.setBoolean(5, noti.isRead());
-            stmt.setString(6, noti.getUrlRedirect());
-            stmt.setTimestamp(7, Timestamp.valueOf(noti.getCreatedAt()));
-            stmt.setInt(8, noti.getNotificationId());
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Đánh dấu đã đọc
-    public boolean markAsRead(int notificationId) throws SQLException {
-        String sql = "UPDATE notifications SET is_read = 1 WHERE notification_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, notificationId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Xóa thông báo
-    public boolean delete(int notificationId) throws SQLException {
-        String sql = "DELETE FROM notifications WHERE notification_id = ?";
-        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
-            stmt.setInt(1, notificationId);
-            return stmt.executeUpdate() > 0;
-        }
-    }
-
-    // Hàm ánh xạ dữ liệu từ ResultSet
-    private Notification mapResultSetToNotification(ResultSet rs) throws SQLException {
-        Notification n = new Notification();
-        n.setNotificationId(rs.getInt("notification_id"));
-        n.setUserId(rs.getInt("user_id"));
-        n.setType(rs.getString("type"));
-        n.setTitle(rs.getString("title"));
-        n.setMessage(rs.getString("message"));
-        n.setRead(rs.getBoolean("is_read"));
-        n.setUrlRedirect(rs.getString("url_redirect"));
-
-        Timestamp created = rs.getTimestamp("created_at");
-        n.setCreatedAt(created != null ? created.toLocalDateTime() : LocalDateTime.now());
-
-        return n;
-    }
-}
Index: src/main/java/model/Chapter.java
===================================================================
diff --git a/src/main/java/model/Chapter.java b/src/main/java/model/Chapter.java
deleted file mode 100644
--- a/src/main/java/model/Chapter.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,111 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Chapter {
-    private int chapterId;
-    private int chapterNumber;
-    private int seriesId;
-    private int userId;
-    private String title;
-    private String content;
-    private String status;
-    private boolean isDeleted;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-
-    public Chapter(int chapterId, int chapterNumber, int seriesId, int userId, String title, String content, String status, boolean isDeleted, LocalDateTime createdAt, LocalDateTime updatedAt) {
-        this.chapterId = chapterId;
-        this.chapterNumber = chapterNumber;
-        this.seriesId = seriesId;
-        this.userId = userId;
-        this.title = title;
-        this.content = content;
-        this.status = status;
-        this.isDeleted = isDeleted;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-    }
-
-    public Chapter() {}
-
-    public int getChapterId() {
-        return chapterId;
-    }
-
-    public void setChapterId(int chapterId) {
-        this.chapterId = chapterId;
-    }
-
-    public boolean isDeleted() {
-        return isDeleted;
-    }
-
-    public void setDeleted(boolean deleted) {
-        isDeleted = deleted;
-    }
-
-    public int getChapterNumber() {
-        return chapterNumber;
-    }
-
-    public void setChapterNumber(int chapterNumber) {
-        this.chapterNumber = chapterNumber;
-    }
-
-    public int getSeriesId() {
-        return seriesId;
-    }
-
-    public void setSeriesId(int seriesId) {
-        this.seriesId = seriesId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public String getTitle() {
-        return title;
-    }
-
-    public void setTitle(String title) {
-        this.title = title;
-    }
-
-    public String getContent() {
-        return content;
-    }
-
-    public void setContent(String content) {
-        this.content = content;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public void setStatus(String status) {
-        this.status = status;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-}
Index: src/main/java/model/Comment.java
===================================================================
diff --git a/src/main/java/model/Comment.java b/src/main/java/model/Comment.java
deleted file mode 100644
--- a/src/main/java/model/Comment.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,81 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Comment {
-    private int commentId;
-    private int userId;
-    private int chapterId;
-    private String content;
-    private boolean isDeleted;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-
-    public Comment(int commentId, int userId, int chapterId, String content, boolean isDeleted, LocalDateTime createdAt, LocalDateTime updatedAt) {
-        this.commentId = commentId;
-        this.userId = userId;
-        this.chapterId = chapterId;
-        this.content = content;
-        this.isDeleted = isDeleted;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-    }
-
-    public Comment() {}
-
-    public int getCommentId() {
-        return commentId;
-    }
-
-    public void setCommentId(int commentId) {
-        this.commentId = commentId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public int getChapterId() {
-        return chapterId;
-    }
-
-    public void setChapterId(int chapterId) {
-        this.chapterId = chapterId;
-    }
-
-    public String getContent() {
-        return content;
-    }
-
-    public void setContent(String content) {
-        this.content = content;
-    }
-
-    public boolean isDeleted() {
-        return isDeleted;
-    }
-
-    public void setDeleted(boolean deleted) {
-        isDeleted = deleted;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-}
Index: .idea/jarRepositories.xml
===================================================================
diff --git a/.idea/jarRepositories.xml b/.idea/jarRepositories.xml
deleted file mode 100644
--- a/.idea/jarRepositories.xml	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="RemoteRepositoriesConfiguration">
-    <remote-repository>
-      <option name="id" value="central" />
-      <option name="name" value="Central Repository" />
-      <option name="url" value="https://repo.maven.apache.org/maven2" />
-    </remote-repository>
-    <remote-repository>
-      <option name="id" value="central" />
-      <option name="name" value="Maven Central repository" />
-      <option name="url" value="https://repo1.maven.org/maven2" />
-    </remote-repository>
-    <remote-repository>
-      <option name="id" value="jboss.community" />
-      <option name="name" value="JBoss Community repository" />
-      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
-    </remote-repository>
-  </component>
-</project>
\ No newline at end of file
Index: src/main/java/model/Notification.java
===================================================================
diff --git a/src/main/java/model/Notification.java b/src/main/java/model/Notification.java
deleted file mode 100644
--- a/src/main/java/model/Notification.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,92 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Notification {
-    private int notificationId;
-    private int userId;
-    private String type;
-    private String title;
-    private String message;
-    private boolean isRead;
-    private String urlRedirect;
-    private LocalDateTime createdAt;
-
-    public Notification(int notificationId, int userId, String type, String title, String message, boolean isRead, String urlRedirect, LocalDateTime createdAt) {
-        this.notificationId = notificationId;
-        this.userId = userId;
-        this.type = type;
-        this.title = title;
-        this.message = message;
-        this.isRead = isRead;
-        this.urlRedirect = urlRedirect;
-        this.createdAt = createdAt;
-    }
-
-    public Notification() {
-    }
-
-    public int getNotificationId() {
-        return notificationId;
-    }
-
-    public void setNotificationId(int notificationId) {
-        this.notificationId = notificationId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public String getType() {
-        return type;
-    }
-
-    public void setType(String type) {
-        this.type = type;
-    }
-
-    public String getTitle() {
-        return title;
-    }
-
-    public void setTitle(String title) {
-        this.title = title;
-    }
-
-    public String getMessage() {
-        return message;
-    }
-
-    public void setMessage(String message) {
-        this.message = message;
-    }
-
-    public boolean isRead() {
-        return isRead;
-    }
-
-    public void setRead(boolean read) {
-        isRead = read;
-    }
-
-    public String getUrlRedirect() {
-        return urlRedirect;
-    }
-
-    public void setUrlRedirect(String urlRedirect) {
-        this.urlRedirect = urlRedirect;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-}
Index: src/main/java/model/User.java
===================================================================
diff --git a/src/main/java/model/User.java b/src/main/java/model/User.java
deleted file mode 100644
--- a/src/main/java/model/User.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,139 +0,0 @@
-package model;
-import java.time.LocalDateTime;
-
-public class User {
-    private int userId;
-    private String username;
-    private String fullName;
-    private String bio;
-    private String passwordHash;
-    private String role;
-    private String email;
-    private String status;
-    private boolean isVerified;
-    private LocalDateTime createdAt;
-    private LocalDateTime updatedAt;
-    private int points;
-    private boolean isDeleted;
-
-    public User(int userId, String username, String fullName, String bio, String passwordHash, String role, String email, String status, boolean isVerified, LocalDateTime createdAt, LocalDateTime updatedAt, int points, boolean isDeleted) {
-        this.userId = userId;
-        this.username = username;
-        this.fullName = fullName;
-        this.bio = bio;
-        this.passwordHash = passwordHash;
-        this.role = role;
-        this.email = email;
-        this.status = status;
-        this.isVerified = isVerified;
-        this.createdAt = createdAt;
-        this.updatedAt = updatedAt;
-        this.points = points;
-        this.isDeleted = isDeleted;
-    }
-
-    public User() {}
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public String getUsername() {
-        return username;
-    }
-
-    public void setUsername(String username) {
-        this.username = username;
-    }
-
-    public String getFullName() {
-        return fullName;
-    }
-
-    public void setFullName(String fullName) {
-        this.fullName = fullName;
-    }
-
-    public String getBio() {
-        return bio;
-    }
-
-    public void setBio(String bio) {
-        this.bio = bio;
-    }
-
-    public String getPasswordHash() {
-        return passwordHash;
-    }
-
-    public void setPasswordHash(String passwordHash) {
-        this.passwordHash = passwordHash;
-    }
-
-    public String getRole() {
-        return role;
-    }
-
-    public void setRole(String role) {
-        this.role = role;
-    }
-
-    public String getEmail() {
-        return email;
-    }
-
-    public void setEmail(String email) {
-        this.email = email;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public void setStatus(String status) {
-        this.status = status;
-    }
-
-    public boolean isVerified() {
-        return isVerified;
-    }
-
-    public void setVerified(boolean verified) {
-        isVerified = verified;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-
-    public LocalDateTime getUpdatedAt() {
-        return updatedAt;
-    }
-
-    public void setUpdatedAt(LocalDateTime updatedAt) {
-        this.updatedAt = updatedAt;
-    }
-
-    public int getPoints() {
-        return points;
-    }
-
-    public void setPoints(int points) {
-        this.points = points;
-    }
-
-    public boolean isDeleted() {
-        return isDeleted;
-    }
-
-    public void setDeleted(boolean deleted) {
-        isDeleted = deleted;
-    }
-}
Index: pom.xml
===================================================================
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
--- a/pom.xml	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,78 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>com</groupId>
-    <artifactId>JoyLeeBook</artifactId>
-    <version>2.0</version>
-    <packaging>war</packaging>
-    <name>JoyLeeBook-2.0</name>
-
-    <properties>
-        <maven.compiler.source>17</maven.compiler.source>
-        <maven.compiler.target>17</maven.compiler.target>
-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-        <failOnMissingWebXml>false</failOnMissingWebXml>
-    </properties>
-
-    <dependencies>
-        <!-- Jakarta Servlet API -->
-        <dependency>
-            <groupId>jakarta.servlet</groupId>
-            <artifactId>jakarta.servlet-api</artifactId>
-            <version>6.0.0</version>
-            <scope>provided</scope>
-        </dependency>
-        <!-- JSTL API -->
-        <dependency>
-            <groupId>jakarta.servlet.jsp.jstl</groupId>
-            <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
-            <version>3.0.0</version>
-        </dependency>
-
-        <!-- JSTL Implementation -->
-        <dependency>
-            <groupId>org.glassfish.web</groupId>
-            <artifactId>jakarta.servlet.jsp.jstl</artifactId>
-            <version>3.0.1</version>
-        </dependency>
-        <!-- Microsoft SQL Server JDBC Driver -->
-        <dependency>
-            <groupId>com.microsoft.sqlserver</groupId>
-            <artifactId>mssql-jdbc</artifactId>
-            <version>12.6.0.jre11</version>
-        </dependency>
-
-        <!--Jakarta RESTful Web Services (JAX-RS)-->
-        <dependency>
-            <groupId>jakarta.ws.rs</groupId>
-            <artifactId>jakarta.ws.rs-api</artifactId>
-            <version>3.1.0</version>
-            <scope>provided</scope>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <plugins>
-            <!-- Compiler Plugin -->
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.11.0</version>
-                <configuration>
-                    <source>17</source>
-                    <target>17</target>
-                </configuration>
-            </plugin>
-
-            <!-- WAR Plugin -->
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-war-plugin</artifactId>
-                <version>3.4.0</version>
-                <configuration>
-                    <failOnMissingWebXml>false</failOnMissingWebXml>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-</project>
\ No newline at end of file
Index: src/main/java/model/SeriesAuthor.java
===================================================================
diff --git a/src/main/java/model/SeriesAuthor.java b/src/main/java/model/SeriesAuthor.java
deleted file mode 100644
--- a/src/main/java/model/SeriesAuthor.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,43 +0,0 @@
-package model;
-
-
-import java.time.LocalDateTime;
-
-public class SeriesAuthor {
-    private int seriesId;
-    private int authorId;
-    private LocalDateTime addedAt;
-
-    public SeriesAuthor(int seriesId, int authorId, LocalDateTime addedAt) {
-        this.seriesId = seriesId;
-        this.authorId = authorId;
-        this.addedAt = addedAt;
-    }
-
-    public SeriesAuthor() {
-    }
-
-    public int getSeriesId() {
-        return seriesId;
-    }
-
-    public void setSeriesId(int seriesId) {
-        this.seriesId = seriesId;
-    }
-
-    public int getAuthorId() {
-        return authorId;
-    }
-
-    public void setAuthorId(int authorId) {
-        this.authorId = authorId;
-    }
-
-    public LocalDateTime getAddedAt() {
-        return addedAt;
-    }
-
-    public void setAddedAt(LocalDateTime addedAt) {
-        this.addedAt = addedAt;
-    }
-}
Index: src/main/java/dao/SeriesDAO.java
===================================================================
diff --git a/src/main/java/dao/SeriesDAO.java b/src/main/java/dao/SeriesDAO.java
deleted file mode 100644
--- a/src/main/java/dao/SeriesDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,389 +0,0 @@
-package dao;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-import java.sql.Timestamp;
-import java.time.LocalDateTime;
-import java.util.*;
-
-import model.Series;
-import model.SeriesAuthor;
-
-/**
- * Data Access Object (DAO) for the Series entity.
- * Provides methods to perform CRUD operations on the series table in the database.
- *
- * @author KToan, HaiDD-dev
- */
-public class SeriesDAO {
-    private final Connection conn;
-
-    public SeriesDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Retrieves all non-deleted series from the database.
-     *
-     * @return a list of Series objects
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getAll() throws SQLException {
-        List<Series> list = new ArrayList<>();
-        String sql = "SELECT * FROM series WHERE is_deleted = 0";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {
-            while (rs.next()) {
-                list.add(extractSeriesFromResultSet(rs));
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Finds a series by its ID.
-     *
-     * @param seriesId the ID of the series to find
-     * @return the Series object if found, otherwise null
-     * @throws SQLException if a database access error occurs
-     */
-    public Series findById(int seriesId) throws SQLException {
-        String sql = "SELECT * FROM series WHERE series_id = ? AND is_deleted = 0";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, seriesId);
-            try (ResultSet rs = ps.executeQuery()) {
-                if (rs.next()) {
-                    Series s = new Series();
-                    s.setSeriesId(rs.getInt("series_id"));
-                    s.setTitle(rs.getNString("title"));
-                    s.setDescription(rs.getNString("description"));
-                    s.setCoverImgUrl(rs.getNString("cover_image_url"));
-                    s.setStatus(rs.getString("status"));
-                    s.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
-                    return s;
-                }
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Inserts a new series into the database.
-     *
-     * @param series   the Series object to insert
-     * @param authorId the ID of the author associated with the series
-     * @return true if the insertion was successful, otherwise false
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean insert(Series series, int authorId) throws SQLException {
-        String sql = "INSERT INTO series (title, description, cover_image_url, status, created_at, updated_at, is_deleted, rating_points) VALUES (?, ?, ?, ?, ?, ?, false, 0)";
-
-        try (PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
-            ps.setString(1, series.getTitle());
-            ps.setInt(2, authorId);
-            ps.setString(3, series.getDescription());
-            ps.setString(4, series.getCoverImgUrl());
-            ps.setString(5, series.getStatus());
-            ps.setTimestamp(6, Timestamp.valueOf(LocalDateTime.now()));
-            ps.setTimestamp(7, Timestamp.valueOf(LocalDateTime.now()));
-
-            int affected = ps.executeUpdate();
-            if (affected > 0) {
-                try (ResultSet rs = ps.getGeneratedKeys()) {
-                    if (rs.next()) {
-                        series.setSeriesId(rs.getInt(1));
-                    }
-                    SeriesAuthorDAO seriesAuthorDAO = new SeriesAuthorDAO(conn);
-                    SeriesAuthor seriesAuthor = new SeriesAuthor(series.getSeriesId(), authorId, LocalDateTime.now());
-                    seriesAuthorDAO.add(seriesAuthor);
-                }
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Updates an existing series in the database.
-     *
-     * @param series the Series object with updated data
-     * @return true if the update was successful, otherwise false
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean update(Series series) throws SQLException {
-        String sql = "UPDATE series SET title = ?, description = ?, cover_image_url = ?, status = ?, updated_at = ?, rating_points = ? WHERE series_id = ? AND is_deleted = false";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setString(1, series.getTitle());
-            ps.setString(2, series.getDescription());
-            ps.setString(3, series.getCoverImgUrl());
-            ps.setString(4, series.getStatus());
-            ps.setTimestamp(5, Timestamp.valueOf(LocalDateTime.now()));
-            ps.setInt(6, series.getSeriesId());
-            ps.setInt(7, series.getRating_points());
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Soft deletes a series by setting its is_deleted flag to true.
-     *
-     * @param seriesId the ID of the series to delete
-     * @return true if the deletion was successful, otherwise false
-     * @throws SQLException if a database access error occurs
-     */
-    public boolean delete(int seriesId) throws SQLException {
-        String sql = "UPDATE series SET is_deleted = true, updated_at = ? WHERE series_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));
-            ps.setInt(2, seriesId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Retrieves the top-rated series from the database.
-     *
-     * @param limit the maximum number of series to retrieve
-     * @return a list of top-rated Series objects
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getTopRatedSeries(int limit) throws SQLException {
-        List<Series> topSerieslist = new ArrayList<>();
-        String sql = "SELECT TOP (" + limit + ") s.series_id, title, rating_points, description, cover_image_url, status, updated_at" + " FROM series s ORDER BY rating_points DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                Series s = new Series();
-                s.setSeriesId(rs.getInt("series_id"));
-                s.setTitle(rs.getNString("title"));
-                s.setDescription(rs.getNString("description"));
-                s.setCoverImgUrl(rs.getNString("cover_image_url"));
-                s.setStatus(rs.getString("status"));
-                s.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
-                topSerieslist.add(s);
-            }
-            return topSerieslist;
-        }
-    }
-
-    /**
-     * Retrieves the total count of series in the database.
-     *
-     * @return the total number of series
-     * @throws SQLException if a database access error occurs
-     */
-    public int getTotalSeriesCount() throws SQLException {
-        String sql = "SELECT COUNT(*) FROM series";
-        try (PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {
-            if (rs.next()) {
-                return rs.getInt(1);
-            }
-        }
-        return 0;
-    }
-
-    /**
-     * Counts the number of series associated with a specific category.
-     *
-     * @param categoryId the ID of the category
-     * @return the count of series in the specified category
-     * @throws SQLException if a database access error occurs
-     */
-    public int countSeriesByCategory(int categoryId) throws SQLException {
-        String sql = "SELECT COUNT(*) FROM series s " + "JOIN series_categories sc ON s.series_id = sc.series_id " + "WHERE sc.category_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, categoryId);
-            ResultSet rs = ps.executeQuery();
-            if (rs.next()) {
-                return rs.getInt(1);
-            }
-        }
-        return 0;
-    }
-
-    /**
-     * Retrieves a list of series associated with a specific author.
-     *
-     * @param authorId the ID of the author
-     * @return a list of Series objects associated with the author
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getSeriesByAuthorId(int authorId) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT * FROM series s " + "JOIN dbo.series_author sa ON s.series_id = sa.series_id " + "WHERE sa.user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, authorId);
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Retrieves a list of series associated with a specific category.
-     *
-     * @param categoryId the ID of the category
-     * @return a list of Series objects associated with the category
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getSeriesByCategoryId(int categoryId) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT * FROM series s JOIN series_categories sc ON s.series_id = sc.series_id WHERE sc.category_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, categoryId);
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Retrieves a list of series based on their status.
-     *
-     * @param limit  the maximum number of series to retrieve
-     * @param status the status of the series to filter by
-     * @return a list of Series objects with the specified status
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getSeriesByStatus(int limit, String status) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT TOP (" + limit + ") * FROM series WHERE status = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setString(1, status);
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Searches for series by name using a LIKE query.
-     *
-     * @param name the name or partial name of the series to search for
-     * @return a list of Series objects that match the search criteria
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> findByName(String name) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT * FROM series WHERE title LIKE ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setString(1, "%" + name + "%");
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Retrieves a list of recently updated series.
-     *
-     * @param limit the maximum number of series to retrieve
-     * @return a list of recently updated Series objects
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getRecentlyUpdated(int limit) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT TOP (" + limit + ") * FROM series ORDER BY updated_at DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Retrieves a list of newly released series.
-     *
-     * @param limit the maximum number of series to retrieve
-     * @return a list of newly released Series objects
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getNewReleasedSeries(int limit) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT TOP (" + limit + ") * FROM series ORDER BY created_at DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Retrieves a list of series that have received the most ratings in the current week.
-     *
-     * @param limit the maximum number of series to retrieve
-     * @return a list of Series objects with the highest ratings this week
-     * @throws SQLException if a database access error occurs
-     */
-    public List<Series> getWeeklySeries(int limit) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT TOP (" + limit + ")s.series_id, title, rating_points, description, cover_image_url, status, updated_at,  SUM(r.score) AS total_rating " + "FROM series s JOIN ratings r ON s.series_id = r.series_id " + "WHERE DATEPART(WEEK, r.rated_at) = DATEPART(WEEK, GETDATE()) AND DATEPART(YEAR, r.rated_at) = DATEPART(YEAR, GETDATE()) " + "GROUP BY s.series_id, title, rating_points, description, cover_image_url, status, updated_at ORDER BY total_rating DESC";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                Series s = new Series();
-                s.setSeriesId(rs.getInt("series_id"));
-                s.setTitle(rs.getNString("title"));
-                s.setDescription(rs.getNString("description"));
-                s.setCoverImgUrl(rs.getNString("cover_image_url"));
-                s.setStatus(rs.getString("status"));
-                s.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
-                s.setRating_points(rs.getInt("total_rating"));
-                seriesList.add(s);
-            }
-            return seriesList;
-        }
-    }
-
-
-    public List<Series> getSeriesByUserId(int userId) throws SQLException {
-        List<Series> seriesList = new ArrayList<>();
-        String sql = "SELECT * FROM series s JOIN saved_series ss ON s.series_id = ss.series_id WHERE ss.user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            ResultSet rs = ps.executeQuery();
-            while (rs.next()) {
-                seriesList.add(extractSeriesFromResultSet(rs));
-            }
-            return seriesList;
-        }
-    }
-
-    /**
-     * Utility method to extract a Series object from a ResultSet.
-     *
-     * @param rs the ResultSet to extract data from
-     * @return the extracted Series object
-     * @throws SQLException if a database access error occurs
-     */
-    private Series extractSeriesFromResultSet(ResultSet rs) throws SQLException {
-        Series s = new Series();
-        s.setSeriesId(rs.getInt("series_id"));
-        s.setTitle(rs.getString("title"));
-        s.setDescription(rs.getString("description"));
-//        s.setCoverImgUrl(rs.getString("cover_image_url"));
-
-        s.setCoverImgUrl("img/thenewkidinschool.png");
-        s.setStatus(rs.getString("status"));
-        s.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
-        s.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
-        s.setDeleted(rs.getBoolean("is_deleted"));
-        s.setRating_points(rs.getInt("rating_points"));
-        return s;
-    }
-}
Index: src/main/java/model/PointHistory.java
===================================================================
diff --git a/src/main/java/model/PointHistory.java b/src/main/java/model/PointHistory.java
deleted file mode 100644
--- a/src/main/java/model/PointHistory.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,81 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class PointHistory {
-    private int historyId;
-    private int userId;
-    private int pointChange;
-    private String reason;
-    private String referenceType;
-    private int referenceId;
-    private LocalDateTime createdAt;
-
-    public PointHistory(int historyId, int userId, int pointChange, String reason, String referenceType, int referenceId, LocalDateTime createdAt) {
-        this.historyId = historyId;
-        this.userId = userId;
-        this.pointChange = pointChange;
-        this.reason = reason;
-        this.referenceType = referenceType;
-        this.referenceId = referenceId;
-        this.createdAt = createdAt;
-    }
-
-    public PointHistory() {}
-
-    public int getHistoryId() {
-        return historyId;
-    }
-
-    public void setHistoryId(int historyId) {
-        this.historyId = historyId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public int getPointChange() {
-        return pointChange;
-    }
-
-    public void setPointChange(int pointChange) {
-        this.pointChange = pointChange;
-    }
-
-    public String getReason() {
-        return reason;
-    }
-
-    public void setReason(String reason) {
-        this.reason = reason;
-    }
-
-    public String getReferenceType() {
-        return referenceType;
-    }
-
-    public void setReferenceType(String referenceType) {
-        this.referenceType = referenceType;
-    }
-
-    public int getReferenceId() {
-        return referenceId;
-    }
-
-    public void setReferenceId(int referenceId) {
-        this.referenceId = referenceId;
-    }
-
-    public LocalDateTime getCreatedAt() {
-        return createdAt;
-    }
-
-    public void setCreatedAt(LocalDateTime createdAt) {
-        this.createdAt = createdAt;
-    }
-}
Index: src/main/java/dao/ReadingHistoryDAO.java
===================================================================
diff --git a/src/main/java/dao/ReadingHistoryDAO.java b/src/main/java/dao/ReadingHistoryDAO.java
deleted file mode 100644
--- a/src/main/java/dao/ReadingHistoryDAO.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,149 +0,0 @@
-package dao;
-
-import model.ReadingHistory;
-
-import java.sql.*;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Data Access Object for ReadingHistory
- *
- * @author KToan, HaiDD-dev
- */
-public class ReadingHistoryDAO {
-    private final Connection conn;
-
-    public ReadingHistoryDAO(Connection conn) {
-        this.conn = conn;
-    }
-
-    /**
-     * Extracts a ReadingHistory object from the current row of the given ResultSet.
-     *
-     * @param rs The ResultSet to extract data from.
-     * @return A ReadingHistory object populated with data from the ResultSet.
-     * @throws SQLException If an SQL error occurs while accessing the ResultSet.
-     */
-    private ReadingHistory extractReadingHistoryFromResultSet(ResultSet rs) throws SQLException {
-        ReadingHistory rh = new ReadingHistory();
-        rh.setUserId(rs.getInt("user_id"));
-        rh.setChapterId(rs.getInt("chapter_id"));
-        Timestamp ts = rs.getTimestamp("last_read_at");
-        rh.setLastReadAt(ts != null ? ts.toLocalDateTime() : null);
-        return rh;
-    }
-
-    /**
-     * Inserts a new ReadingHistory record into the database.
-     *
-     * @param rh The ReadingHistory object to insert.
-     * @return true if the insertion was successful, false otherwise.
-     * @throws SQLException If an SQL error occurs during the insertion.
-     */
-    public boolean insert(ReadingHistory rh) throws SQLException {
-        String sql = "INSERT INTO reading_history (user_id, chapter_id, last_read_at) VALUES (?, ?, ?)";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, rh.getUserId());
-            ps.setInt(2, rh.getChapterId());
-            ps.setTimestamp(3, Timestamp.valueOf(rh.getLastReadAt()));
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Retrieves all ReadingHistory records from the database.
-     *
-     * @return A list of all ReadingHistory records.
-     * @throws SQLException If an SQL error occurs during the retrieval.
-     */
-    public List<ReadingHistory> getAll() throws SQLException {
-        List<ReadingHistory> list = new ArrayList<>();
-        String sql = "SELECT * FROM reading_history";
-        try (Statement st = conn.createStatement(); ResultSet rs = st.executeQuery(sql)) {
-            while (rs.next()) {
-                list.add(extractReadingHistoryFromResultSet(rs));
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Retrieves all ReadingHistory records for a specific user.
-     *
-     * @param userId The ID of the user whose reading history is to be retrieved.
-     * @return A list of ReadingHistory records for the specified user.
-     * @throws SQLException If an SQL error occurs during the retrieval.
-     */
-    public List<ReadingHistory> getByUserId(int userId) throws SQLException {
-        List<ReadingHistory> list = new ArrayList<>();
-        String sql = "SELECT * FROM reading_history WHERE user_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            try (ResultSet rs = ps.executeQuery()) {
-                while (rs.next()) {
-                    list.add(extractReadingHistoryFromResultSet(rs));
-                }
-            }
-        }
-        return list;
-    }
-
-    /**
-     * Updates an existing ReadingHistory record in the database.
-     *
-     * @param rh The ReadingHistory object containing updated data.
-     * @return true if the update was successful, false otherwise.
-     * @throws SQLException If an SQL error occurs during the update.
-     */
-    public boolean update(ReadingHistory rh) throws SQLException {
-        String sql = "UPDATE reading_history SET last_read_at = ? WHERE user_id = ? AND chapter_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setTimestamp(1, Timestamp.valueOf(rh.getLastReadAt()));
-            ps.setInt(2, rh.getUserId());
-            ps.setInt(3, rh.getChapterId());
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Deletes a ReadingHistory record from the database.
-     *
-     * @param userId    The ID of the user.
-     * @param chapterId The ID of the chapter.
-     * @return true if the deletion was successful, false otherwise.
-     * @throws SQLException If an SQL error occurs during the deletion.
-     */
-    public boolean delete(int userId, int chapterId) throws SQLException {
-        String sql = "DELETE FROM reading_history WHERE user_id = ? AND chapter_id = ?";
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            ps.setInt(2, chapterId);
-            return ps.executeUpdate() > 0;
-        }
-    }
-
-    /**
-     * Upserts a ReadingHistory record in the database. If a record with the given userId and chapterId exists,
-     * it updates the last_read_at timestamp. If it does not exist, it inserts a new record.
-     *
-     * @param userId    The ID of the user.
-     * @param chapterId The ID of the chapter.
-     * @throws SQLException If an SQL error occurs during the upsert operation.
-     */
-    public void upsert(int userId, int chapterId) throws SQLException {
-        String sql = """
-                    MERGE reading_history AS t
-                    USING (SELECT ? AS user_id, ? AS chapter_id) AS s
-                    ON (t.user_id = s.user_id AND t.chapter_id = s.chapter_id)
-                    WHEN MATCHED THEN UPDATE SET last_read_at = GETDATE()
-                    WHEN NOT MATCHED THEN INSERT (user_id, chapter_id, last_read_at)
-                         VALUES (s.user_id, s.chapter_id, GETDATE());
-                """;
-        try (PreparedStatement ps = conn.prepareStatement(sql)) {
-            ps.setInt(1, userId);
-            ps.setInt(2, chapterId);
-            ps.executeUpdate();
-        }
-    }
-}
Index: src/main/java/model/Like.java
===================================================================
diff --git a/src/main/java/model/Like.java b/src/main/java/model/Like.java
deleted file mode 100644
--- a/src/main/java/model/Like.java	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ /dev/null	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
@@ -1,42 +0,0 @@
-package model;
-
-import java.time.LocalDateTime;
-
-public class Like {
-    private int userId;
-    private int chapterId;
-    private LocalDateTime likedAt;
-
-    public Like(int userId, int chapterId, LocalDateTime likedAt) {
-        this.userId = userId;
-        this.chapterId = chapterId;
-        this.likedAt = likedAt;
-    }
-
-    public Like() {
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public void setUserId(int userId) {
-        this.userId = userId;
-    }
-
-    public int getChapterId() {
-        return chapterId;
-    }
-
-    public void setChapterId(int chapterId) {
-        this.chapterId = chapterId;
-    }
-
-    public LocalDateTime getLikedAt() {
-        return likedAt;
-    }
-
-    public void setLikedAt(LocalDateTime likedAt) {
-        this.likedAt = likedAt;
-    }
-}
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"VcsDirectoryMappings\">\r\n    <mapping directory=\"\" vcs=\"Git\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
--- a/.idea/vcs.xml	(revision 708ab8da304c39fe221ba87cdff1a8de36d45f5a)
+++ b/.idea/vcs.xml	(date 1760529772645)
@@ -2,5 +2,6 @@
 <project version="4">
   <component name="VcsDirectoryMappings">
     <mapping directory="" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/JoyLeeBook_v2.0" vcs="Git" />
   </component>
 </project>
\ No newline at end of file
Index: .idea/Project.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Project.iml b/.idea/Project.iml
new file mode 100644
--- /dev/null	(date 1760529772629)
+++ b/.idea/Project.iml	(date 1760529772629)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1760529772635)
+++ b/.idea/modules.xml	(date 1760529772635)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/Project.iml" filepath="$PROJECT_DIR$/.idea/Project.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/artifacts/unnamed.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/artifacts/unnamed.xml b/.idea/artifacts/unnamed.xml
new file mode 100644
--- /dev/null	(date 1760529772640)
+++ b/.idea/artifacts/unnamed.xml	(date 1760529772640)
@@ -0,0 +1,9 @@
+<component name="ArtifactManager">
+  <artifact type="exploded-war" name="unnamed">
+    <output-path>$PROJECT_DIR$/out/artifacts/unnamed</output-path>
+    <root id="root">
+      <element id="dir-copy" path="$PROJECT_DIR$/JoyLeeBook_v2.0/src/main/webapp/META-INF" />
+      <element id="dir-copy" path="$PROJECT_DIR$/JoyLeeBook_v2.0/src/main/webapp/WEB-INF" />
+    </root>
+  </artifact>
+</component>
\ No newline at end of file
